# ğŸ¤”ğŸ‘€çº¿æ€§è¡¨(æ•£åˆ—) - å“ˆå¸Œè¡¨

æ•£åˆ—è¡¨ï¼ˆHash tableï¼Œä¹Ÿå«å“ˆå¸Œè¡¨ï¼‰ï¼Œæ˜¯æ ¹æ®å…³é”®ç å€¼(Key value)è€Œç›´æ¥è¿›è¡Œè®¿é—®çš„æ•°æ®ç»“æ„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒé€šè¿‡æŠŠå…³é”®ç å€¼æ˜ å°„åˆ°è¡¨ä¸­ä¸€ä¸ªä½ç½®æ¥è®¿é—®è®°å½•ï¼Œä»¥åŠ å¿«æŸ¥æ‰¾çš„é€Ÿåº¦ã€‚è¿™ä¸ªæ˜ å°„å‡½æ•°å«åšæ•£åˆ—å‡½æ•°ï¼Œå­˜æ”¾è®°å½•çš„æ•°ç»„å«åšæ•£åˆ—è¡¨ã€‚

## å“ˆå¸Œè¡¨ç›¸å…³é¢˜ç›®

å“ˆå¸Œè¡¨ä½¿ç”¨ O(N) ç©ºé—´å¤æ‚åº¦å­˜å‚¨æ•°æ®ï¼Œå¹¶ä¸”ä»¥ O(1) æ—¶é—´å¤æ‚åº¦æ±‚è§£é—®é¢˜ã€‚

- Java ä¸­çš„  **HashSet**  ç”¨äºå­˜å‚¨ä¸€ä¸ªé›†åˆï¼Œå¯ä»¥æŸ¥æ‰¾å…ƒç´ æ˜¯å¦åœ¨é›†åˆä¸­ã€‚å¦‚æœå…ƒç´ æœ‰ç©·ï¼Œå¹¶ä¸”èŒƒå›´ä¸å¤§ï¼Œé‚£ä¹ˆå¯ä»¥ç”¨ä¸€ä¸ªå¸ƒå°”æ•°ç»„æ¥å­˜å‚¨ä¸€ä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨ã€‚ä¾‹å¦‚å¯¹äºåªæœ‰å°å†™å­—ç¬¦çš„å…ƒç´ ï¼Œå°±å¯ä»¥ç”¨ä¸€ä¸ªé•¿åº¦ä¸º 26 çš„å¸ƒå°”æ•°ç»„æ¥å­˜å‚¨ä¸€ä¸ªå­—ç¬¦é›†åˆï¼Œä½¿å¾—ç©ºé—´å¤æ‚åº¦é™ä½ä¸º O(1)ã€‚



- Java ä¸­çš„  **HashMap**  ä¸»è¦ç”¨äºæ˜ å°„å…³ç³»ï¼Œä»è€ŒæŠŠä¸¤ä¸ªå…ƒç´ è”ç³»èµ·æ¥ã€‚HashMap ä¹Ÿå¯ä»¥ç”¨æ¥å¯¹å…ƒç´ è¿›è¡Œè®¡æ•°ç»Ÿè®¡ï¼Œæ­¤æ—¶é”®ä¸ºå…ƒç´ ï¼Œå€¼ä¸ºè®¡æ•°ã€‚å’Œ HashSet ç±»ä¼¼ï¼Œå¦‚æœå…ƒç´ æœ‰ç©·å¹¶ä¸”èŒƒå›´ä¸å¤§ï¼Œå¯ä»¥ç”¨æ•´å‹æ•°ç»„æ¥è¿›è¡Œç»Ÿè®¡ã€‚åœ¨å¯¹ä¸€ä¸ªå†…å®¹è¿›è¡Œå‹ç¼©æˆ–è€…å…¶å®ƒè½¬æ¢æ—¶ï¼Œåˆ©ç”¨ HashMap å¯ä»¥æŠŠåŸå§‹å†…å®¹å’Œè½¬æ¢åçš„å†…å®¹è”ç³»èµ·æ¥ã€‚ä¾‹å¦‚åœ¨ä¸€ä¸ªç®€åŒ– url çš„ç³»ç»Ÿä¸­åˆ©ç”¨ HashMap å°±å¯ä»¥å­˜å‚¨ç²¾ç®€åçš„ url åˆ°åŸå§‹ url çš„æ˜ å°„ï¼Œä½¿å¾—ä¸ä»…å¯ä»¥æ˜¾ç¤ºç®€åŒ–çš„ urlï¼Œä¹Ÿå¯ä»¥æ ¹æ®ç®€åŒ–çš„ url å¾—åˆ°åŸå§‹ url ä»è€Œå®šä½åˆ°æ­£ç¡®çš„èµ„æºã€‚

  

**æ•°ç»„ä¸­ä¸¤ä¸ªæ•°çš„å’Œä¸ºç»™å®šå€¼**

å¯ä»¥å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åä½¿ç”¨åŒæŒ‡é’ˆæ–¹æ³•æˆ–è€…äºŒåˆ†æŸ¥æ‰¾æ–¹æ³•ã€‚è¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦ä¸º O(NlogN)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚



ç”¨ HashMap å­˜å‚¨æ•°ç»„å…ƒç´ å’Œç´¢å¼•çš„æ˜ å°„ï¼Œåœ¨è®¿é—®åˆ° nums[i] æ—¶ï¼Œåˆ¤æ–­ HashMap ä¸­æ˜¯å¦å­˜åœ¨ target - nums[i]ï¼Œå¦‚æœå­˜åœ¨è¯´æ˜ target - nums[i] æ‰€åœ¨çš„ç´¢å¼•å’Œ i å°±æ˜¯è¦æ‰¾çš„ä¸¤ä¸ªæ•°ã€‚è¯¥æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(N)ï¼Œä½¿ç”¨ç©ºé—´æ¥æ¢å–æ—¶é—´ã€‚

```java
public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> indexForNum = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (indexForNum.containsKey(target - nums[i])) {
            return new int[]{indexForNum.get(target - nums[i]), i};
        } else {
            indexForNum.put(nums[i], i);
        }
    }
    return null;
}
```

**åˆ¤æ–­æ•°ç»„æ˜¯å¦å«æœ‰é‡å¤å…ƒç´ **

```jva
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int num : nums) {
        set.add(num);
    }
    return set.size() < nums.length;
}
```

**æœ€é•¿å’Œè°åºåˆ—**

```html
Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].
```

å’Œè°åºåˆ—ä¸­æœ€å¤§æ•°å’Œæœ€å°æ•°åªå·®æ­£å¥½ä¸º 1ï¼Œåº”è¯¥æ³¨æ„çš„æ˜¯åºåˆ—çš„å…ƒç´ ä¸ä¸€å®šæ˜¯æ•°ç»„çš„è¿ç»­å…ƒç´ ã€‚

```java
public int findLHS(int[] nums) {
    Map<Integer, Integer> countForNum = new HashMap<>();
    for (int num : nums) {
        countForNum.put(num, countForNum.getOrDefault(num, 0) + 1);
    }
    int longest = 0;
    for (int num : countForNum.keySet()) {
        if (countForNum.containsKey(num + 1)) {
            longest = Math.max(longest, countForNum.get(num + 1) + countForNum.get(num));
        }
    }
    return longest;
}
```

**æœ€é•¿è¿ç»­åºåˆ—**

```html
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
```

è¦æ±‚ä»¥ O(N) çš„æ—¶é—´å¤æ‚åº¦æ±‚è§£ã€‚

```java
public int longestConsecutive(int[] nums) {
    Map<Integer, Integer> countForNum = new HashMap<>();
    for (int num : nums) {
        countForNum.put(num, 1);
    }
    for (int num : nums) {
        forward(countForNum, num);
    }
    return maxCount(countForNum);
}

private int forward(Map<Integer, Integer> countForNum, int num) {
    if (!countForNum.containsKey(num)) {
        return 0;
    }
    int cnt = countForNum.get(num);
    if (cnt > 1) {
        return cnt;
    }
    cnt = forward(countForNum, num + 1) + 1;
    countForNum.put(num, cnt);
    return cnt;
}

private int maxCount(Map<Integer, Integer> countForNum) {
    int max = 0;
    for (int num : countForNum.keySet()) {
        max = Math.max(max, countForNum.get(num));
    }
    return max;
}
```

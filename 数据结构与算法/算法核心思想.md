ğŸ¤”ğŸ‘€ç®—æ³•æ€æƒ³



## ç®—æ³•æ€æƒ³è¯¦è§£

- ç®—æ³•æ€æƒ³ - åˆ†æ²»ç®—æ³•

  - åˆ†æ²»ç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯å°†ä¸€ä¸ªè§„æ¨¡ä¸ºNçš„é—®é¢˜åˆ†è§£ä¸ºKä¸ªè§„æ¨¡è¾ƒå°çš„å­é—®é¢˜ï¼Œè¿™äº›å­é—®é¢˜ç›¸äº’ç‹¬ç«‹ä¸”ä¸åŸé—®é¢˜æ€§è´¨ç›¸åŒã€‚æ±‚å‡ºå­é—®é¢˜çš„è§£ï¼Œå°±å¯å¾—åˆ°åŸé—®é¢˜çš„è§£

  

- ç®—æ³•æ€æƒ³ - åŠ¨æ€è§„åˆ’ç®—æ³•

  - åŠ¨æ€è§„åˆ’ç®—æ³•é€šå¸¸ç”¨äºæ±‚è§£å…·æœ‰æŸç§æœ€ä¼˜æ€§è´¨çš„é—®é¢˜ã€‚åœ¨è¿™ç±»é—®é¢˜ä¸­ï¼Œå¯èƒ½ä¼šæœ‰è®¸å¤šå¯è¡Œè§£ã€‚æ¯ä¸€ä¸ªè§£éƒ½å¯¹åº”äºä¸€ä¸ªå€¼ï¼Œæˆ‘ä»¬å¸Œæœ›æ‰¾åˆ°å…·æœ‰æœ€ä¼˜å€¼çš„è§£ã€‚åŠ¨æ€è§„åˆ’ç®—æ³•ä¸åˆ†æ²»æ³•ç±»ä¼¼ï¼Œå…¶åŸºæœ¬æ€æƒ³ä¹Ÿæ˜¯å°†å¾…æ±‚è§£é—®é¢˜åˆ†è§£æˆè‹¥å¹²ä¸ªå­é—®é¢˜ï¼Œå…ˆæ±‚è§£å­é—®é¢˜ï¼Œç„¶åä»è¿™äº›å­é—®é¢˜çš„è§£å¾—åˆ°åŸé—®é¢˜çš„è§£

  

- ç®—æ³•æ€æƒ³ - è´ªå¿ƒç®—æ³•

  - ç®—æ³•ä¸­è´ªå¿ƒç®—æ³•çš„æ€æƒ³: ä¿è¯æ¯æ¬¡æ“ä½œéƒ½æ˜¯å±€éƒ¨æœ€ä¼˜çš„ï¼Œå¹¶ä¸”æœ€åå¾—åˆ°çš„ç»“æœæ˜¯å…¨å±€æœ€ä¼˜çš„

  

- ç®—æ³•æ€æƒ³ - äºŒåˆ†æ³•

  - ç®—æ³•æ€æƒ³ä¸­åˆ†æ²»ç®—æ³•é‡è¦çš„äºŒåˆ†æ³•ï¼Œæ¯”å¦‚äºŒåˆ†æŸ¥æ‰¾ï¼›äºŒåˆ†æŸ¥æ‰¾ä¹Ÿç§°æŠ˜åŠæŸ¥æ‰¾ï¼ˆBinary Searchï¼‰ï¼Œå®ƒæ˜¯ä¸€ç§æ•ˆç‡è¾ƒé«˜çš„æŸ¥æ‰¾æ–¹æ³•ã€‚ä½†æ˜¯ï¼ŒæŠ˜åŠæŸ¥æ‰¾è¦æ±‚çº¿æ€§è¡¨å¿…é¡»é‡‡ç”¨é¡ºåºå­˜å‚¨ç»“æ„ï¼Œè€Œä¸”è¡¨ä¸­å…ƒç´ æŒ‰å…³é”®å­—æœ‰åºæ’åˆ—ã€‚

  

- ç®—æ³•æ€æƒ³ - æœç´¢ç®—æ³•

  - ç®—æ³•ä¸­æœç´¢ç®—æ³•çš„æ€æƒ³ï¼Œä¸»è¦åŒ…å«BFSï¼ŒDFS

  

- ç®—æ³•æ€æƒ³ - å›æº¯ç®—æ³•

  - Backtracking(å›æº¯)å±äº DFS, æœ¬æ–‡ä¸»è¦ä»‹ç»ç®—æ³•ä¸­Backtrackingç®—æ³•çš„æ€æƒ³ã€‚å›æº¯ç®—æ³•å®é™…ä¸Šä¸€ä¸ªç±»ä¼¼æšä¸¾çš„æœç´¢å°è¯•è¿‡ç¨‹ï¼Œä¸»è¦æ˜¯åœ¨æœç´¢å°è¯•è¿‡ç¨‹ä¸­å¯»æ‰¾é—®é¢˜çš„è§£ï¼Œå½“å‘ç°å·²ä¸æ»¡è¶³æ±‚è§£æ¡ä»¶æ—¶ï¼Œå°±â€œå›æº¯â€è¿”å›ï¼Œå°è¯•åˆ«çš„è·¯å¾„ã€‚å›æº¯æ³•æ˜¯ä¸€ç§é€‰ä¼˜æœç´¢æ³•ï¼ŒæŒ‰é€‰ä¼˜æ¡ä»¶å‘å‰æœç´¢ï¼Œä»¥è¾¾åˆ°ç›®æ ‡ã€‚ä½†å½“æ¢ç´¢åˆ°æŸä¸€æ­¥æ—¶ï¼Œå‘ç°åŸå…ˆé€‰æ‹©å¹¶ä¸ä¼˜æˆ–è¾¾ä¸åˆ°ç›®æ ‡ï¼Œå°±é€€å›ä¸€æ­¥é‡æ–°é€‰æ‹©ï¼Œè¿™ç§èµ°ä¸é€šå°±é€€å›å†èµ°çš„æŠ€æœ¯ä¸ºå›æº¯æ³•



## ç®—æ³•æ€æƒ³ - åˆ†æ²»ç®—æ³•

åˆ†æ²»ç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯å°†ä¸€ä¸ªè§„æ¨¡ä¸ºNçš„é—®é¢˜åˆ†è§£ä¸ºKä¸ªè§„æ¨¡è¾ƒå°çš„å­é—®é¢˜ï¼Œè¿™äº›å­é—®é¢˜ç›¸äº’ç‹¬ç«‹ä¸”ä¸åŸé—®é¢˜æ€§è´¨ç›¸åŒã€‚æ±‚å‡ºå­é—®é¢˜çš„è§£ï¼Œå°±å¯å¾—åˆ°åŸé—®é¢˜çš„è§£ã€‚

## åˆ†æ²»ç›¸å…³é¢˜ç›®

### ç»™è¡¨è¾¾å¼åŠ æ‹¬å·

```html
Input: "2-1-1".

((2-1)-1) = 0
(2-(1-1)) = 2

Output : [0, 2]
```

```java
public List<Integer> diffWaysToCompute(String input) {
    List<Integer> ways = new ArrayList<>();
    for (int i = 0; i < input.length(); i++) {
        char c = input.charAt(i);
        if (c == '+' || c == '-' || c == '*') {
            List<Integer> left = diffWaysToCompute(input.substring(0, i));
            List<Integer> right = diffWaysToCompute(input.substring(i + 1));
            for (int l : left) {
                for (int r : right) {
                    switch (c) {
                        case '+':
                            ways.add(l + r);
                            break;
                        case '-':
                            ways.add(l - r);
                            break;
                        case '*':
                            ways.add(l * r);
                            break;
                    }
                }
            }
        }
    }
    if (ways.size() == 0) {
        ways.add(Integer.valueOf(input));
    }
    return ways;
}
```

# ç®—æ³•æ€æƒ³ - åŠ¨æ€è§„åˆ’ç®—æ³•



åŠ¨æ€è§„åˆ’ç®—æ³•é€šå¸¸ç”¨äºæ±‚è§£å…·æœ‰æŸç§æœ€ä¼˜æ€§è´¨çš„é—®é¢˜ã€‚åœ¨è¿™ç±»é—®é¢˜ä¸­ï¼Œå¯èƒ½ä¼šæœ‰è®¸å¤šå¯è¡Œè§£ã€‚æ¯ä¸€ä¸ªè§£éƒ½å¯¹åº”äºä¸€ä¸ªå€¼ï¼Œæˆ‘ä»¬å¸Œæœ›æ‰¾åˆ°å…·æœ‰æœ€ä¼˜å€¼çš„è§£ã€‚åŠ¨æ€è§„åˆ’ç®—æ³•ä¸åˆ†æ²»æ³•ç±»ä¼¼ï¼Œå…¶åŸºæœ¬æ€æƒ³ä¹Ÿæ˜¯å°†å¾…æ±‚è§£é—®é¢˜åˆ†è§£æˆè‹¥å¹²ä¸ªå­é—®é¢˜ï¼Œå…ˆæ±‚è§£å­é—®é¢˜ï¼Œç„¶åä»è¿™äº›å­é—®é¢˜çš„è§£å¾—åˆ°åŸé—®é¢˜çš„è§£ã€‚åŠ¨æ€è§„åˆ’ç®—æ³•åœ¨ç®—æ³•æ€æƒ³ä¸­æ˜¯æä¸ºé‡è¦çš„ï¼Œéœ€è¦é‡ç‚¹æŒæ¡ã€‚

## åŠ¨æ€è§„åˆ’ç›¸å…³é¢˜ç›®

é€’å½’å’ŒåŠ¨æ€è§„åˆ’éƒ½æ˜¯å°†åŸé—®é¢˜æ‹†æˆå¤šä¸ªå­é—®é¢˜ç„¶åæ±‚è§£ï¼Œä»–ä»¬ä¹‹é—´æœ€æœ¬è´¨çš„åŒºåˆ«æ˜¯ï¼ŒåŠ¨æ€è§„åˆ’ä¿å­˜äº†å­é—®é¢˜çš„è§£ï¼Œé¿å…é‡å¤è®¡ç®—ã€‚

### æ–æ³¢é‚£å¥‘æ•°åˆ—

#### çˆ¬æ¥¼æ¢¯

é¢˜ç›®æè¿°: æœ‰ N é˜¶æ¥¼æ¢¯ï¼Œæ¯æ¬¡å¯ä»¥ä¸Šä¸€é˜¶æˆ–è€…ä¸¤é˜¶ï¼Œæ±‚æœ‰å¤šå°‘ç§ä¸Šæ¥¼æ¢¯çš„æ–¹æ³•ã€‚

å®šä¹‰ä¸€ä¸ªæ•°ç»„ dp å­˜å‚¨ä¸Šæ¥¼æ¢¯çš„æ–¹æ³•æ•°(ä¸ºäº†æ–¹ä¾¿è®¨è®ºï¼Œæ•°ç»„ä¸‹æ ‡ä» 1 å¼€å§‹)ï¼Œdp[i] è¡¨ç¤ºèµ°åˆ°ç¬¬ i ä¸ªæ¥¼æ¢¯çš„æ–¹æ³•æ•°ç›®ã€‚

ç¬¬ i ä¸ªæ¥¼æ¢¯å¯ä»¥ä»ç¬¬ i-1 å’Œ i-2 ä¸ªæ¥¼æ¢¯å†èµ°ä¸€æ­¥åˆ°è¾¾ï¼Œèµ°åˆ°ç¬¬ i ä¸ªæ¥¼æ¢¯çš„æ–¹æ³•æ•°ä¸ºèµ°åˆ°ç¬¬ i-1 å’Œç¬¬ i-2 ä¸ªæ¥¼æ¢¯çš„æ–¹æ³•æ•°ä¹‹å’Œã€‚

![7c98e1b6-c446-4cde-8513-5c11b9f52aea](Images/7c98e1b6-c446-4cde-8513-5c11b9f52aea.jpg)

è€ƒè™‘åˆ° dp[i] åªä¸ dp[i - 1] å’Œ dp[i - 2] æœ‰å…³ï¼Œå› æ­¤å¯ä»¥åªç”¨ä¸¤ä¸ªå˜é‡æ¥å­˜å‚¨ dp[i - 1] å’Œ dp[i - 2]ï¼Œä½¿å¾—åŸæ¥çš„ O(N) ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–ä¸º O(1) å¤æ‚åº¦ã€‚

```java
public int climbStairs(int n) {
    if (n <= 2) {
        return n;
    }
    int pre2 = 1, pre1 = 2;
    for (int i = 2; i < n; i++) {
        int cur = pre1 + pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}
```



#### å¼ºç›—æŠ¢åŠ«

é¢˜ç›®æè¿°: æŠ¢åŠ«ä¸€æ’ä½æˆ·ï¼Œä½†æ˜¯ä¸èƒ½æŠ¢é‚»è¿‘çš„ä½æˆ·ï¼Œæ±‚æœ€å¤§æŠ¢åŠ«é‡ã€‚

å®šä¹‰ dp æ•°ç»„ç”¨æ¥å­˜å‚¨æœ€å¤§çš„æŠ¢åŠ«é‡ï¼Œå…¶ä¸­ dp[i] è¡¨ç¤ºæŠ¢åˆ°ç¬¬ i ä¸ªä½æˆ·æ—¶çš„æœ€å¤§æŠ¢åŠ«é‡ã€‚

ç”±äºä¸èƒ½æŠ¢åŠ«é‚»è¿‘ä½æˆ·ï¼Œå› æ­¤å¦‚æœæŠ¢åŠ«äº†ç¬¬ i ä¸ªä½æˆ·é‚£ä¹ˆåªèƒ½æŠ¢åŠ« i - 2 æˆ–è€… i - 3 çš„ä½æˆ·ï¼Œæ‰€ä»¥

![gif](Images/gif.gif)

```java
public int rob(int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return nums[0];
    }
    int pre3 = 0, pre2 = 0, pre1 = 0;
    for (int i = 0; i < n; i++) {
        int cur = Math.max(pre2, pre3) + nums[i];
        pre3 = pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    return Math.max(pre1, pre2);
}
```



#### å¼ºç›—åœ¨ç¯å½¢è¡—åŒºæŠ¢åŠ«

```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    if (n == 1) {
        return nums[0];
    }
    return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));
}

private int rob(int[] nums, int first, int last) {
    int pre3 = 0, pre2 = 0, pre1 = 0;
    for (int i = first; i <= last; i++) {
        int cur = Math.max(pre3, pre2) + nums[i];
        pre3 = pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    return Math.max(pre2, pre1);
}
```

#### ä¿¡ä»¶é”™æ’

é¢˜ç›®æè¿°: æœ‰ N ä¸ª ä¿¡ å’Œ ä¿¡å°ï¼Œå®ƒä»¬è¢«æ‰“ä¹±ï¼Œæ±‚é”™è¯¯è£…ä¿¡æ–¹å¼çš„æ•°é‡ã€‚

å®šä¹‰ä¸€ä¸ªæ•°ç»„ dp å­˜å‚¨é”™è¯¯æ–¹å¼æ•°é‡ï¼Œdp[i] è¡¨ç¤ºå‰ i ä¸ªä¿¡å’Œä¿¡å°çš„é”™è¯¯æ–¹å¼æ•°é‡ã€‚å‡è®¾ç¬¬ i ä¸ªä¿¡è£…åˆ°ç¬¬ j ä¸ªä¿¡å°é‡Œé¢ï¼Œè€Œç¬¬ j ä¸ªä¿¡è£…åˆ°ç¬¬ k ä¸ªä¿¡å°é‡Œé¢ã€‚æ ¹æ® i å’Œ k æ˜¯å¦ç›¸ç­‰ï¼Œæœ‰ä¸¤ç§æƒ…å†µ:

- i==kï¼Œäº¤æ¢ i å’Œ k çš„ä¿¡åï¼Œå®ƒä»¬çš„ä¿¡å’Œä¿¡å°åœ¨æ­£ç¡®çš„ä½ç½®ï¼Œä½†æ˜¯å…¶ä½™ i-2 å°ä¿¡æœ‰ dp[i-2] ç§é”™è¯¯è£…ä¿¡çš„æ–¹å¼ã€‚ç”±äº j æœ‰ i-1 ç§å–å€¼ï¼Œå› æ­¤å…±æœ‰ (i-1)*dp[i-2] ç§é”™è¯¯è£…ä¿¡æ–¹å¼ã€‚
- i != kï¼Œäº¤æ¢ i å’Œ j çš„ä¿¡åï¼Œç¬¬ i ä¸ªä¿¡å’Œä¿¡å°åœ¨æ­£ç¡®çš„ä½ç½®ï¼Œå…¶ä½™ i-1 å°ä¿¡æœ‰ dp[i-1] ç§é”™è¯¯è£…ä¿¡æ–¹å¼ã€‚ç”±äº j æœ‰ i-1 ç§å–å€¼ï¼Œå› æ­¤å…±æœ‰ (i-1)*dp[i-1] ç§é”™è¯¯è£…ä¿¡æ–¹å¼ã€‚

ç»¼ä¸Šæ‰€è¿°ï¼Œé”™è¯¯è£…ä¿¡æ•°é‡æ–¹å¼æ•°é‡ä¸º:

![gif (1)](Images/gif%20(1)-16352391237211.gif)



#### æ¯ç‰›ç”Ÿäº§

é¢˜ç›®æè¿°: å‡è®¾å†œåœºä¸­æˆç†Ÿçš„æ¯ç‰›æ¯å¹´éƒ½ä¼šç”Ÿ 1 å¤´å°æ¯ç‰›ï¼Œå¹¶ä¸”æ°¸è¿œä¸ä¼šæ­»ã€‚ç¬¬ä¸€å¹´æœ‰ 1 åªå°æ¯ç‰›ï¼Œä»ç¬¬äºŒå¹´å¼€å§‹ï¼Œæ¯ç‰›å¼€å§‹ç”Ÿå°æ¯ç‰›ã€‚æ¯åªå°æ¯ç‰› 3 å¹´ä¹‹åæˆç†Ÿåˆå¯ä»¥ç”Ÿå°æ¯ç‰›ã€‚ç»™å®šæ•´æ•° Nï¼Œæ±‚ N å¹´åç‰›çš„æ•°é‡ã€‚

ç¬¬ i å¹´æˆç†Ÿçš„ç‰›çš„æ•°é‡ä¸º:

![gif (2)](Images/gif%20(2).gif)





### çŸ©é˜µè·¯å¾„

#### çŸ©é˜µçš„æœ€å°è·¯å¾„å’Œ

```html
[[1,3,1],
 [1,5,1],
 [4,2,1]]
Given the above grid map, return 7. Because the path 1â†’3â†’1â†’1â†’1 minimizes the sum.
```

é¢˜ç›®æè¿°: æ±‚ä»çŸ©é˜µçš„å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„æœ€å°è·¯å¾„å’Œï¼Œæ¯æ¬¡åªèƒ½å‘å³å’Œå‘ä¸‹ç§»åŠ¨ã€‚

```java
public int minPathSum(int[][] grid) {
    if (grid.length == 0 || grid[0].length == 0) {
        return 0;
    }
    int m = grid.length, n = grid[0].length;
    int[] dp = new int[n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0) {
                dp[j] = dp[j - 1];
            } else {
                dp[j] = Math.min(dp[j - 1], dp[j]);
            }
            dp[j] += grid[i][j];
        }
    }
    return dp[n - 1];
}
```

#### çŸ©é˜µçš„æ€»è·¯å¾„æ•°

é¢˜ç›®æè¿°: ç»Ÿè®¡ä»çŸ©é˜µå·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„æ€»æ•°ï¼Œæ¯æ¬¡åªèƒ½å‘å³æˆ–è€…å‘ä¸‹ç§»åŠ¨ã€‚

![7c98e1b6-c446-4cde-8513-5c11b9f52aea (1)](Images/7c98e1b6-c446-4cde-8513-5c11b9f52aea%20(1).jpg)



```java
public int uniquePaths(int m, int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j] + dp[j - 1];
        }
    }
    return dp[n - 1];
}
```

ä¹Ÿå¯ä»¥ç›´æ¥ç”¨æ•°å­¦å…¬å¼æ±‚è§£ï¼Œè¿™æ˜¯ä¸€ä¸ªç»„åˆé—®é¢˜ã€‚æœºå™¨äººæ€»å…±ç§»åŠ¨çš„æ¬¡æ•° S=m+n-2ï¼Œå‘ä¸‹ç§»åŠ¨çš„æ¬¡æ•° D=m-1ï¼Œé‚£ä¹ˆé—®é¢˜å¯ä»¥çœ‹æˆä» S ä»å–å‡º D ä¸ªä½ç½®çš„ç»„åˆæ•°é‡ï¼Œè¿™ä¸ªé—®é¢˜çš„è§£ä¸º C(S, D)ã€‚

```java
public int uniquePaths(int m, int n) {
    int S = m + n - 2;  // æ€»å…±çš„ç§»åŠ¨æ¬¡æ•°
    int D = m - 1;      // å‘ä¸‹çš„ç§»åŠ¨æ¬¡æ•°
    long ret = 1;
    for (int i = 1; i <= D; i++) {
        ret = ret * (S - D + i) / i;
    }
    return (int) ret;
}
```

### æ•°ç»„åŒºé—´

#### æ•°ç»„åŒºé—´å’Œ

```html
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```

æ±‚åŒºé—´ i ~ j çš„å’Œï¼Œå¯ä»¥è½¬æ¢ä¸º sum[j] - sum[i-1]ï¼Œå…¶ä¸­ sum[i] ä¸º 0 ~ i çš„å’Œã€‚

```java
class NumArray {

    private int[] sums;

    public NumArray(int[] nums) {
        sums = new int[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
    }

    public int sumRange(int i, int j) {
        return sums[j + 1] - sums[i];
    }
}
```



#### å­æ•°ç»„æœ€å¤§çš„å’Œ

```html
For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
```

```java
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int preSum = nums[0];
    int maxSum = preSum;
    for (int i = 1; i < nums.length; i++) {
        preSum = preSum > 0 ? preSum + nums[i] : nums[i];
        maxSum = Math.max(maxSum, preSum);
    }
    return maxSum;
}
```

#### æ•°ç»„ä¸­ç­‰å·®é€’å¢å­åŒºé—´çš„ä¸ªæ•°

```html
A = [1, 2, 3, 4]
return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
```

dp[i] è¡¨ç¤ºä»¥ A[i] ä¸ºç»“å°¾çš„ç­‰å·®é€’å¢å­åŒºé—´çš„ä¸ªæ•°ã€‚

åœ¨ A[i] - A[i - 1] == A[i - 1] - A[i - 2] çš„æ¡ä»¶ä¸‹ï¼Œ{A[i - 2], A[i - 1], A[i]} æ˜¯ä¸€ä¸ªç­‰å·®é€’å¢å­åŒºé—´ã€‚å¦‚æœ {A[i - 3], A[i - 2], A[i - 1]} æ˜¯ä¸€ä¸ªç­‰å·®é€’å¢å­åŒºé—´ï¼Œé‚£ä¹ˆ {A[i - 3], A[i - 2], A[i - 1], A[i]} ä¹Ÿæ˜¯ç­‰å·®é€’å¢å­åŒºé—´ï¼Œdp[i] = dp[i-1] + 1ã€‚

```java
public int numberOfArithmeticSlices(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    int n = A.length;
    int[] dp = new int[n];
    for (int i = 2; i < n; i++) {
        if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
            dp[i] = dp[i - 1] + 1;
        }
    }
    int total = 0;
    for (int cnt : dp) {
        total += cnt;
    }
    return total;
}
```

### åˆ†å‰²æ•´æ•°

#### åˆ†å‰²æ•´æ•°çš„æœ€å¤§ä¹˜ç§¯

é¢˜ç›®æè¿°: For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i - 1; j++) {
            dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));
        }
    }
    return dp[n];
}
```

#### æŒ‰å¹³æ–¹æ•°æ¥åˆ†å‰²æ•´æ•°

é¢˜ç›®æè¿°: For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.

```java
public int numSquares(int n) {
    List<Integer> squareList = generateSquareList(n);
    int[] dp = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        int min = Integer.MAX_VALUE;
        for (int square : squareList) {
            if (square > i) {
                break;
            }
            min = Math.min(min, dp[i - square] + 1);
        }
        dp[i] = min;
    }
    return dp[n];
}

private List<Integer> generateSquareList(int n) {
    List<Integer> squareList = new ArrayList<>();
    int diff = 3;
    int square = 1;
    while (square <= n) {
        squareList.add(square);
        square += diff;
        diff += 2;
    }
    return squareList;
}
```

#### åˆ†å‰²æ•´æ•°æ„æˆå­—æ¯å­—ç¬¦ä¸²

é¢˜ç›®æè¿°: Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    for (int i = 2; i <= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0) {
            dp[i] += dp[i - 1];
        }
        if (s.charAt(i - 2) == '0') {
            continue;
        }
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two <= 26) {
            dp[i] += dp[i - 2];
        }
    }
    return dp[n];
}
```

### æœ€é•¿é€’å¢å­åºåˆ—

å·²çŸ¥ä¸€ä¸ªåºåˆ— {S1, S2,...,Sn}ï¼Œå–å‡ºè‹¥å¹²æ•°ç»„æˆæ–°çš„åºåˆ— {Si1, Si2,..., Sim}ï¼Œå…¶ä¸­ i1ã€i2 ... im ä¿æŒé€’å¢ï¼Œå³æ–°åºåˆ—ä¸­å„ä¸ªæ•°ä»ç„¶ä¿æŒåŸæ•°åˆ—ä¸­çš„å…ˆåé¡ºåºï¼Œç§°æ–°åºåˆ—ä¸ºåŸåºåˆ—çš„ä¸€ä¸ª å­åºåˆ— ã€‚

å¦‚æœåœ¨å­åºåˆ—ä¸­ï¼Œå½“ä¸‹æ ‡ ix > iy æ—¶ï¼ŒSix > Siyï¼Œç§°å­åºåˆ—ä¸ºåŸåºåˆ—çš„ä¸€ä¸ª é€’å¢å­åºåˆ— ã€‚



å®šä¹‰ä¸€ä¸ªæ•°ç»„ dp å­˜å‚¨æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦ï¼Œdp[n] è¡¨ç¤ºä»¥ Sn ç»“å°¾çš„åºåˆ—çš„æœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦ã€‚å¯¹äºä¸€ä¸ªé€’å¢å­åºåˆ— {Si1, Si2,...,Sim}ï¼Œå¦‚æœ im < n å¹¶ä¸” Sim < Snï¼Œæ­¤æ—¶ {Si1, Si2,..., Sim, Sn} ä¸ºä¸€ä¸ªé€’å¢å­åºåˆ—ï¼Œé€’å¢å­åºåˆ—çš„é•¿åº¦å¢åŠ  1ã€‚æ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„é€’å¢å­åºåˆ—ä¸­ï¼Œé•¿åº¦æœ€é•¿çš„é‚£ä¸ªé€’å¢å­åºåˆ—å°±æ˜¯è¦æ‰¾çš„ï¼Œåœ¨é•¿åº¦æœ€é•¿çš„é€’å¢å­åºåˆ—ä¸ŠåŠ ä¸Š Sn å°±æ„æˆäº†ä»¥ Sn ä¸ºç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—ã€‚å› æ­¤ dp[n] = max{ dp[i]+1 | Si < Sn && i < n} ã€‚

å› ä¸ºåœ¨æ±‚ dp[n] æ—¶å¯èƒ½æ— æ³•æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„é€’å¢å­åºåˆ—ï¼Œæ­¤æ—¶ {Sn} å°±æ„æˆäº†é€’å¢å­åºåˆ—ï¼Œéœ€è¦å¯¹å‰é¢çš„æ±‚è§£æ–¹ç¨‹åšä¿®æ”¹ï¼Œä»¤ dp[n] æœ€å°ä¸º 1ï¼Œå³:



å¯¹äºä¸€ä¸ªé•¿åº¦ä¸º N çš„åºåˆ—ï¼Œæœ€é•¿é€’å¢å­åºåˆ—å¹¶ä¸ä¸€å®šä¼šä»¥ SN ä¸ºç»“å°¾ï¼Œå› æ­¤ dp[N] ä¸æ˜¯åºåˆ—çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦ï¼Œéœ€è¦éå† dp æ•°ç»„æ‰¾å‡ºæœ€å¤§å€¼æ‰æ˜¯æ‰€è¦çš„ç»“æœï¼Œmax{ dp[i] | 1 <= i <= N} å³ä¸ºæ‰€æ±‚ã€‚



#### æœ€é•¿é€’å¢å­åºåˆ—

```java
public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    for (int i = 0; i < n; i++) {
        int max = 1;
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                max = Math.max(max, dp[j] + 1);
            }
        }
        dp[i] = max;
    }
    return Arrays.stream(dp).max().orElse(0);
}
```

ä½¿ç”¨ Stream æ±‚æœ€å¤§å€¼ä¼šå¯¼è‡´è¿è¡Œæ—¶é—´è¿‡é•¿ï¼Œå¯ä»¥æ”¹æˆä»¥ä¸‹å½¢å¼:

```jav
int ret = 0;
for (int i = 0; i < n; i++) {
    ret = Math.max(ret, dp[i]);
}
return ret;
```

ä»¥ä¸Šè§£æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(N2)ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾å°†æ—¶é—´å¤æ‚åº¦é™ä½ä¸º O(NlogN)ã€‚

å®šä¹‰ä¸€ä¸ª tails æ•°ç»„ï¼Œå…¶ä¸­ tails[i] å­˜å‚¨é•¿åº¦ä¸º i + 1 çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚å¯¹äºä¸€ä¸ªå…ƒç´  xï¼Œ

- å¦‚æœå®ƒå¤§äº tails æ•°ç»„æ‰€æœ‰çš„å€¼ï¼Œé‚£ä¹ˆæŠŠå®ƒæ·»åŠ åˆ° tails åé¢ï¼Œè¡¨ç¤ºæœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦åŠ  1ï¼›
- å¦‚æœ tails[i-1] < x <= tails[i]ï¼Œé‚£ä¹ˆæ›´æ–° tails[i-1] = xã€‚

ä¾‹å¦‚å¯¹äºæ•°ç»„ [4,3,6,5]ï¼Œæœ‰:

```html
tails      len      num
[]         0        4
[4]        1        3
[3]        1        6
[3,6]      2        5
[3,5]      2        null
```

å¯ä»¥çœ‹å‡º tails æ•°ç»„ä¿æŒæœ‰åºï¼Œå› æ­¤åœ¨æŸ¥æ‰¾ Si ä½äº tails æ•°ç»„çš„ä½ç½®æ—¶å°±å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ã€‚

```java
public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] tails = new int[n];
    int len = 0;
    for (int num : nums) {
        int index = binarySearch(tails, len, num);
        tails[index] = num;
        if (index == len) {
            len++;
        }
    }
    return len;
}

private int binarySearch(int[] tails, int len, int key) {
    int l = 0, h = len;
    while (l < h) {
        int mid = l + (h - l) / 2;
        if (tails[mid] == key) {
            return mid;
        } else if (tails[mid] > key) {
            h = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
}
```

#### ä¸€ç»„æ•´æ•°å¯¹èƒ½å¤Ÿæ„æˆçš„æœ€é•¿é“¾

```html
Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]
```

é¢˜ç›®æè¿°: å¯¹äº (a, b) å’Œ (c, d) ï¼Œå¦‚æœ b < cï¼Œåˆ™å®ƒä»¬å¯ä»¥æ„æˆä¸€æ¡é“¾ã€‚

```java
public int findLongestChain(int[][] pairs) {
    if (pairs == null || pairs.length == 0) {
        return 0;
    }
    Arrays.sort(pairs, (a, b) -> (a[0] - b[0]));
    int n = pairs.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (pairs[j][1] < pairs[i][0]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return Arrays.stream(dp).max().orElse(0);
}
```

#### æœ€é•¿æ‘†åŠ¨å­åºåˆ—

```html
Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
```

è¦æ±‚: ä½¿ç”¨ O(N) æ—¶é—´å¤æ‚åº¦æ±‚è§£ã€‚

```java
public int wiggleMaxLength(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int up = 1, down = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1]) {
            up = down + 1;
        } else if (nums[i] < nums[i - 1]) {
            down = up + 1;
        }
    }
    return Math.max(up, down);
}
```

### æœ€é•¿å…¬å…±å­åºåˆ—

å¯¹äºä¸¤ä¸ªå­åºåˆ— S1 å’Œ S2ï¼Œæ‰¾å‡ºå®ƒä»¬æœ€é•¿çš„å…¬å…±å­åºåˆ—ã€‚

å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ dp ç”¨æ¥å­˜å‚¨æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ï¼Œå…¶ä¸­ dp[i][j] è¡¨ç¤º S1 çš„å‰ i ä¸ªå­—ç¬¦ä¸ S2 çš„å‰ j ä¸ªå­—ç¬¦æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ã€‚è€ƒè™‘ S1i ä¸ S2j å€¼æ˜¯å¦ç›¸ç­‰ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µ:

- å½“ S1i==S2j æ—¶ï¼Œé‚£ä¹ˆå°±èƒ½åœ¨ S1 çš„å‰ i-1 ä¸ªå­—ç¬¦ä¸ S2 çš„å‰ j-1 ä¸ªå­—ç¬¦æœ€é•¿å…¬å…±å­åºåˆ—çš„åŸºç¡€ä¸Šå†åŠ ä¸Š S1i è¿™ä¸ªå€¼ï¼Œæœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦åŠ  1ï¼Œå³ dp[i][j] = dp[i-1][j-1] + 1ã€‚
- å½“ S1i != S2j æ—¶ï¼Œæ­¤æ—¶æœ€é•¿å…¬å…±å­åºåˆ—ä¸º S1 çš„å‰ i-1 ä¸ªå­—ç¬¦å’Œ S2 çš„å‰ j ä¸ªå­—ç¬¦æœ€é•¿å…¬å…±å­åºåˆ—ï¼Œæˆ–è€… S1 çš„å‰ i ä¸ªå­—ç¬¦å’Œ S2 çš„å‰ j-1 ä¸ªå­—ç¬¦æœ€é•¿å…¬å…±å­åºåˆ—ï¼Œå–å®ƒä»¬çš„æœ€å¤§è€…ï¼Œå³ dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }ã€‚

ç»¼ä¸Šï¼Œæœ€é•¿å…¬å…±å­åºåˆ—çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸º:



å¯¹äºé•¿åº¦ä¸º N çš„åºåˆ— S1 å’Œé•¿åº¦ä¸º M çš„åºåˆ— S2ï¼Œdp[N][M] å°±æ˜¯åºåˆ— S1 å’Œåºåˆ— S2 çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ã€‚

ä¸æœ€é•¿é€’å¢å­åºåˆ—ç›¸æ¯”ï¼Œæœ€é•¿å…¬å…±å­åºåˆ—æœ‰ä»¥ä¸‹ä¸åŒç‚¹:

- é’ˆå¯¹çš„æ˜¯ä¸¤ä¸ªåºåˆ—ï¼Œæ±‚å®ƒä»¬çš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚
- åœ¨æœ€é•¿é€’å¢å­åºåˆ—ä¸­ï¼Œdp[i] è¡¨ç¤ºä»¥ Si ä¸ºç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦ï¼Œå­åºåˆ—å¿…é¡»åŒ…å« Si ï¼›åœ¨æœ€é•¿å…¬å…±å­åºåˆ—ä¸­ï¼Œdp[i][j] è¡¨ç¤º S1 ä¸­å‰ i ä¸ªå­—ç¬¦ä¸ S2 ä¸­å‰ j ä¸ªå­—ç¬¦çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ï¼Œä¸ä¸€å®šåŒ…å« S1i å’Œ S2jã€‚
- åœ¨æ±‚æœ€ç»ˆè§£æ—¶ï¼Œæœ€é•¿å…¬å…±å­åºåˆ—ä¸­ dp[N][M] å°±æ˜¯æœ€ç»ˆè§£ï¼Œè€Œæœ€é•¿é€’å¢å­åºåˆ—ä¸­ dp[N] ä¸æ˜¯æœ€ç»ˆè§£ï¼Œå› ä¸ºä»¥ SN ä¸ºç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—ä¸ä¸€å®šæ˜¯æ•´ä¸ªåºåˆ—æœ€é•¿é€’å¢å­åºåˆ—ï¼Œéœ€è¦éå†ä¸€é dp æ•°ç»„æ‰¾åˆ°æœ€å¤§è€…ã€‚

```java
public int lengthOfLCS(int[] nums1, int[] nums2) {
    int n1 = nums1.length, n2 = nums2.length;
    int[][] dp = new int[n1 + 1][n2 + 1];
    for (int i = 1; i <= n1; i++) {
        for (int j = 1; j <= n2; j++) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[n1][n2];
}
```

### 0-1 èƒŒåŒ…

æœ‰ä¸€ä¸ªå®¹é‡ä¸º N çš„èƒŒåŒ…ï¼Œè¦ç”¨è¿™ä¸ªèƒŒåŒ…è£…ä¸‹ç‰©å“çš„ä»·å€¼æœ€å¤§ï¼Œè¿™äº›ç‰©å“æœ‰ä¸¤ä¸ªå±æ€§: ä½“ç§¯ w å’Œä»·å€¼ vã€‚

å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ dp å­˜å‚¨æœ€å¤§ä»·å€¼ï¼Œå…¶ä¸­ dp[i][j] è¡¨ç¤ºå‰ i ä»¶ç‰©å“ä½“ç§¯ä¸è¶…è¿‡ j çš„æƒ…å†µä¸‹èƒ½è¾¾åˆ°çš„æœ€å¤§ä»·å€¼ã€‚è®¾ç¬¬ i ä»¶ç‰©å“ä½“ç§¯ä¸º wï¼Œä»·å€¼ä¸º vï¼Œæ ¹æ®ç¬¬ i ä»¶ç‰©å“æ˜¯å¦æ·»åŠ åˆ°èƒŒåŒ…ä¸­ï¼Œå¯ä»¥åˆ†ä¸¤ç§æƒ…å†µè®¨è®º:

- ç¬¬ i ä»¶ç‰©å“æ²¡æ·»åŠ åˆ°èƒŒåŒ…ï¼Œæ€»ä½“ç§¯ä¸è¶…è¿‡ j çš„å‰ i ä»¶ç‰©å“çš„æœ€å¤§ä»·å€¼å°±æ˜¯æ€»ä½“ç§¯ä¸è¶…è¿‡ j çš„å‰ i-1 ä»¶ç‰©å“çš„æœ€å¤§ä»·å€¼ï¼Œdp[i][j] = dp[i-1][j]ã€‚
- ç¬¬ i ä»¶ç‰©å“æ·»åŠ åˆ°èƒŒåŒ…ä¸­ï¼Œdp[i][j] = dp[i-1][j-w] + vã€‚

ç¬¬ i ä»¶ç‰©å“å¯æ·»åŠ ä¹Ÿå¯ä»¥ä¸æ·»åŠ ï¼Œå–å†³äºå“ªç§æƒ…å†µä¸‹æœ€å¤§ä»·å€¼æ›´å¤§ã€‚å› æ­¤ï¼Œ0-1 èƒŒåŒ…çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸º:

![gif (3)](Images/gif%20(3).gif)



```java
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```



#### ç©ºé—´ä¼˜åŒ–

åœ¨ç¨‹åºå®ç°æ—¶å¯ä»¥å¯¹ 0-1 èƒŒåŒ…åšä¼˜åŒ–ã€‚è§‚å¯ŸçŠ¶æ€è½¬ç§»æ–¹ç¨‹å¯ä»¥çŸ¥é“ï¼Œå‰ i ä»¶ç‰©å“çš„çŠ¶æ€ä»…ä¸å‰ i-1 ä»¶ç‰©å“çš„çŠ¶æ€æœ‰å…³ï¼Œå› æ­¤å¯ä»¥å°† dp å®šä¹‰ä¸ºä¸€ç»´æ•°ç»„ï¼Œå…¶ä¸­ dp[j] æ—¢å¯ä»¥è¡¨ç¤º dp[i-1][j] ä¹Ÿå¯ä»¥è¡¨ç¤º dp[i][j]ã€‚æ­¤æ—¶ï¼Œ

![gif (4)](Images/gif%20(4)-16352392439202.gif)



å› ä¸º dp[j-w] è¡¨ç¤º dp[i-1][j-w]ï¼Œå› æ­¤ä¸èƒ½å…ˆæ±‚ dp[i][j-w]ï¼Œä»¥é˜²å°† dp[i-1][j-w] è¦†ç›–ã€‚ä¹Ÿå°±æ˜¯è¯´è¦å…ˆè®¡ç®— dp[i][j] å†è®¡ç®— dp[i][j-w]ï¼Œåœ¨ç¨‹åºå®ç°æ—¶éœ€è¦æŒ‰å€’åºæ¥å¾ªç¯æ±‚è§£ã€‚

```java
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j >= 1; j--) {
            if (j >= w) {
                dp[j] = Math.max(dp[j], dp[j - w] + v);
            }
        }
    }
    return dp[W];
}
```

æ— æ³•ä½¿ç”¨è´ªå¿ƒç®—æ³•çš„è§£é‡Š

0-1 èƒŒåŒ…é—®é¢˜æ— æ³•ä½¿ç”¨è´ªå¿ƒç®—æ³•æ¥æ±‚è§£ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸èƒ½æŒ‰ç…§å…ˆæ·»åŠ æ€§ä»·æ¯”æœ€é«˜çš„ç‰©å“æ¥è¾¾åˆ°æœ€ä¼˜ï¼Œè¿™æ˜¯å› ä¸ºè¿™ç§æ–¹å¼å¯èƒ½é€ æˆèƒŒåŒ…ç©ºé—´çš„æµªè´¹ï¼Œä»è€Œæ— æ³•è¾¾åˆ°æœ€ä¼˜ã€‚è€ƒè™‘ä¸‹é¢çš„ç‰©å“å’Œä¸€ä¸ªå®¹é‡ä¸º 5 çš„èƒŒåŒ…ï¼Œå¦‚æœå…ˆæ·»åŠ ç‰©å“ 0 å†æ·»åŠ ç‰©å“ 1ï¼Œé‚£ä¹ˆåªèƒ½å­˜æ”¾çš„ä»·å€¼ä¸º 16ï¼Œæµªè´¹äº†å¤§å°ä¸º 2 çš„ç©ºé—´ã€‚æœ€ä¼˜çš„æ–¹å¼æ˜¯å­˜æ”¾ç‰©å“ 1 å’Œç‰©å“ 2ï¼Œä»·å€¼ä¸º 22.

|  id  |  w   |  v   | v/w  |
| :--: | :--: | :--: | :--: |
|  0   |  1   |  6   |  6   |
|  1   |  2   |  10  |  5   |
|  2   |  3   |  12  |  4   |

å˜ç§

- å®Œå…¨èƒŒåŒ…: ç‰©å“æ•°é‡ä¸ºæ— é™ä¸ª
- å¤šé‡èƒŒåŒ…: ç‰©å“æ•°é‡æœ‰é™åˆ¶
- å¤šç»´è´¹ç”¨èƒŒåŒ…: ç‰©å“ä¸ä»…æœ‰é‡é‡ï¼Œè¿˜æœ‰ä½“ç§¯ï¼ŒåŒæ—¶è€ƒè™‘è¿™ä¸¤ç§é™åˆ¶
- å…¶å®ƒ: ç‰©å“ä¹‹é—´ç›¸äº’çº¦æŸæˆ–è€…ä¾èµ–

#### åˆ’åˆ†æ•°ç»„ä¸ºå’Œç›¸ç­‰çš„ä¸¤éƒ¨åˆ†

```html
Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
```

å¯ä»¥çœ‹æˆä¸€ä¸ªèƒŒåŒ…å¤§å°ä¸º sum/2 çš„ 0-1 èƒŒåŒ…é—®é¢˜ã€‚

```java
public boolean canPartition(int[] nums) {
    int sum = computeArraySum(nums);
    if (sum % 2 != 0) {
        return false;
    }
    int W = sum / 2;
    boolean[] dp = new boolean[W + 1];
    dp[0] = true;
    Arrays.sort(nums);
    for (int num : nums) {                 // 0-1 èƒŒåŒ…ä¸€ä¸ªç‰©å“åªèƒ½ç”¨ä¸€æ¬¡
        for (int i = W; i >= num; i--) {   // ä»åå¾€å‰ï¼Œå…ˆè®¡ç®— dp[i] å†è®¡ç®— dp[i-num]
            dp[i] = dp[i] || dp[i - num];
        }
    }
    return dp[W];
}

private int computeArraySum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}
```

#### æ”¹å˜ä¸€ç»„æ•°çš„æ­£è´Ÿå·ä½¿å¾—å®ƒä»¬çš„å’Œä¸ºä¸€ç»™å®šæ•°

```html
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
```

è¯¥é—®é¢˜å¯ä»¥è½¬æ¢ä¸º Subset Sum é—®é¢˜ï¼Œä»è€Œä½¿ç”¨ 0-1 èƒŒåŒ…çš„æ–¹æ³•æ¥æ±‚è§£ã€‚

å¯ä»¥å°†è¿™ç»„æ•°çœ‹æˆä¸¤éƒ¨åˆ†ï¼ŒP å’Œ Nï¼Œå…¶ä¸­ P ä½¿ç”¨æ­£å·ï¼ŒN ä½¿ç”¨è´Ÿå·ï¼Œæœ‰ä»¥ä¸‹æ¨å¯¼:

```html
                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)
```

å› æ­¤åªè¦æ‰¾åˆ°ä¸€ä¸ªå­é›†ï¼Œä»¤å®ƒä»¬éƒ½å–æ­£å·ï¼Œå¹¶ä¸”å’Œç­‰äº (target + sum(nums))/2ï¼Œå°±è¯æ˜å­˜åœ¨è§£ã€‚

```java
public int findTargetSumWays(int[] nums, int S) {
    int sum = computeArraySum(nums);
    if (sum < S || (sum + S) % 2 == 1) {
        return 0;
    }
    int W = (sum + S) / 2;
    int[] dp = new int[W + 1];
    dp[0] = 1;
    Arrays.sort(nums);
    for (int num : nums) {
        for (int i = W; i >= num; i--) {
            dp[i] = dp[i] + dp[i - num];
        }
    }
    return dp[W];
}

private int computeArraySum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}
```

DFS è§£æ³•:

```java
public int findTargetSumWays(int[] nums, int S) {
    return findTargetSumWays(nums, 0, S);
}

private int findTargetSumWays(int[] nums, int start, int S) {
    if (start == nums.length) {
        return S == 0 ? 1 : 0;
    }
    return findTargetSumWays(nums, start + 1, S + nums[start])
            + findTargetSumWays(nums, start + 1, S - nums[start]);
}
```



#### å­—ç¬¦ä¸²æŒ‰å•è¯åˆ—è¡¨åˆ†å‰²

```html
s = "leetcode",
dict = ["leet", "code"].
Return true because "leetcode" can be segmented as "leet code".
```

dict ä¸­çš„å•è¯æ²¡æœ‰ä½¿ç”¨æ¬¡æ•°çš„é™åˆ¶ï¼Œå› æ­¤è¿™æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ã€‚

0-1 èƒŒåŒ…å’Œå®Œå…¨èƒŒåŒ…åœ¨å®ç°ä¸Šçš„ä¸åŒä¹‹å¤„æ˜¯ï¼Œ0-1 èƒŒåŒ…å¯¹ç‰©å“çš„è¿­ä»£æ˜¯åœ¨æœ€å¤–å±‚ï¼Œè€Œå®Œå…¨èƒŒåŒ…å¯¹ç‰©å“çš„è¿­ä»£æ˜¯åœ¨æœ€é‡Œå±‚ã€‚

```java
public boolean wordBreak(String s, List<String> wordDict) {
    int n = s.length();
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    for (int i = 1; i <= n; i++) {
        for (String word : wordDict) {   // å®Œå…¨ä¸€ä¸ªç‰©å“å¯ä»¥ä½¿ç”¨å¤šæ¬¡
            int len = word.length();
            if (len <= i && word.equals(s.substring(i - len, i))) {
                dp[i] = dp[i] || dp[i - len];
            }
        }
    }
    return dp[n];
}
```

#### 01 å­—ç¬¦æ„æˆæœ€å¤šçš„å­—ç¬¦ä¸²

```html
Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: There are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are "10","0001","1","0"
```

è¿™æ˜¯ä¸€ä¸ªå¤šç»´è´¹ç”¨çš„ 0-1 èƒŒåŒ…é—®é¢˜ï¼Œæœ‰ä¸¤ä¸ªèƒŒåŒ…å¤§å°ï¼Œ0 çš„æ•°é‡å’Œ 1 çš„æ•°é‡ã€‚

```java
public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0) {
        return 0;
    }
    int[][] dp = new int[m + 1][n + 1];
    for (String s : strs) {    // æ¯ä¸ªå­—ç¬¦ä¸²åªèƒ½ç”¨ä¸€æ¬¡
        int ones = 0, zeros = 0;
        for (char c : s.toCharArray()) {
            if (c == '0') {
                zeros++;
            } else {
                ones++;
            }
        }
        for (int i = m; i >= zeros; i--) {
            for (int j = n; j >= ones; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
            }
        }
    }
    return dp[m][n];
}
```

#### æ‰¾é›¶é’±çš„æœ€å°‘ç¡¬å¸æ•°

```html
Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.
```

é¢˜ç›®æè¿°: ç»™ä¸€äº›é¢é¢çš„ç¡¬å¸ï¼Œè¦æ±‚ç”¨è¿™äº›ç¡¬å¸æ¥ç»„æˆç»™å®šé¢é¢çš„é’±æ•°ï¼Œå¹¶ä¸”ä½¿å¾—ç¡¬å¸æ•°é‡æœ€å°‘ã€‚ç¡¬å¸å¯ä»¥é‡å¤ä½¿ç”¨ã€‚

- ç‰©å“: ç¡¬å¸
- ç‰©å“å¤§å°: é¢é¢
- ç‰©å“ä»·å€¼: æ•°é‡

å› ä¸ºç¡¬å¸å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œå› æ­¤è¿™æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ã€‚

```java
public int coinChange(int[] coins, int amount) {
    if (coins == null || coins.length == 0) {
        return 0;
    }
    int[] minimum = new int[amount + 1];
    Arrays.fill(minimum, amount + 1);
    minimum[0] = 0;
    Arrays.sort(coins);
    for (int i = 1; i <= amount; i++) {
        for (int j = 0; j < coins.length && coins[j] <= i; j++) {
            minimum[i] = Math.min(minimum[i], minimum[i - coins[j]] + 1);
        }
    }
    return minimum[amount] > amount ? -1 : minimum[amount];
}
```

#### ç»„åˆæ€»å’Œ

```html
nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
```

#### å®Œå…¨èƒŒåŒ…ã€‚

```java
public int combinationSum4(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int[] maximum = new int[target + 1];
    maximum[0] = 1;
    Arrays.sort(nums);
    for (int i = 1; i <= target; i++) {
        for (int j = 0; j < nums.length && nums[j] <= i; j++) {
            maximum[i] += maximum[i - nums[j]];
        }
    }
    return maximum[target];
}
```

### è‚¡ç¥¨äº¤æ˜“

#### éœ€è¦å†·å´æœŸçš„è‚¡ç¥¨äº¤æ˜“

é¢˜ç›®æè¿°: äº¤æ˜“ä¹‹åéœ€è¦æœ‰ä¸€å¤©çš„å†·å´æ—¶é—´ã€‚

![a3da4342-078b-43e2-b748-7e71bec50dc4](Images/a3da4342-078b-43e2-b748-7e71bec50dc4.png)

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int N = prices.length;
    int[] buy = new int[N];
    int[] s1 = new int[N];
    int[] sell = new int[N];
    int[] s2 = new int[N];
    s1[0] = buy[0] = -prices[0];
    sell[0] = s2[0] = 0;
    for (int i = 1; i < N; i++) {
        buy[i] = s2[i - 1] - prices[i];
        s1[i] = Math.max(buy[i - 1], s1[i - 1]);
        sell[i] = Math.max(buy[i - 1], s1[i - 1]) + prices[i];
        s2[i] = Math.max(s2[i - 1], sell[i - 1]);
    }
    return Math.max(sell[N - 1], s2[N - 1]);
}
```

#### éœ€è¦äº¤æ˜“è´¹ç”¨çš„è‚¡ç¥¨äº¤æ˜“

```html
Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

é¢˜ç›®æè¿°: æ¯äº¤æ˜“ä¸€æ¬¡ï¼Œéƒ½è¦æ”¯ä»˜ä¸€å®šçš„è´¹ç”¨ã€‚

![61942711-45a0-4e11-bbc9-434e31436f33](Images/61942711-45a0-4e11-bbc9-434e31436f33.png)

```java
public int maxProfit(int[] prices, int fee) {
    int N = prices.length;
    int[] buy = new int[N];
    int[] s1 = new int[N];
    int[] sell = new int[N];
    int[] s2 = new int[N];
    s1[0] = buy[0] = -prices[0];
    sell[0] = s2[0] = 0;
    for (int i = 1; i < N; i++) {
        buy[i] = Math.max(sell[i - 1], s2[i - 1]) - prices[i];
        s1[i] = Math.max(buy[i - 1], s1[i - 1]);
        sell[i] = Math.max(buy[i - 1], s1[i - 1]) - fee + prices[i];
        s2[i] = Math.max(s2[i - 1], sell[i - 1]);
    }
    return Math.max(sell[N - 1], s2[N - 1]);
}
```



#### ä¹°å…¥å’Œå”®å‡ºè‚¡ç¥¨æœ€å¤§çš„æ”¶ç›Š

é¢˜ç›®æè¿°: åªè¿›è¡Œä¸€æ¬¡äº¤æ˜“ã€‚

åªè¦è®°å½•å‰é¢çš„æœ€å°ä»·æ ¼ï¼Œå°†è¿™ä¸ªæœ€å°ä»·æ ¼ä½œä¸ºä¹°å…¥ä»·æ ¼ï¼Œç„¶åå°†å½“å‰çš„ä»·æ ¼ä½œä¸ºå”®å‡ºä»·æ ¼ï¼ŒæŸ¥çœ‹å½“å‰æ”¶ç›Šæ˜¯ä¸æ˜¯æœ€å¤§æ”¶ç›Šã€‚

```java
public int maxProfit(int[] prices) {
    int n = prices.length;
    if (n == 0) return 0;
    int soFarMin = prices[0];
    int max = 0;
    for (int i = 1; i < n; i++) {
        if (soFarMin > prices[i]) soFarMin = prices[i];
        else max = Math.max(max, prices[i] - soFarMin);
    }
    return max;
}
```

#### åªèƒ½è¿›è¡Œä¸¤æ¬¡çš„è‚¡ç¥¨äº¤æ˜“

```java
public int maxProfit(int[] prices) {
    int firstBuy = Integer.MIN_VALUE, firstSell = 0;
    int secondBuy = Integer.MIN_VALUE, secondSell = 0;
    for (int curPrice : prices) {
        if (firstBuy < -curPrice) {
            firstBuy = -curPrice;
        }
        if (firstSell < firstBuy + curPrice) {
            firstSell = firstBuy + curPrice;
        }
        if (secondBuy < firstSell - curPrice) {
            secondBuy = firstSell - curPrice;
        }
        if (secondSell < secondBuy + curPrice) {
            secondSell = secondBuy + curPrice;
        }
    }
    return secondSell;
}
```

#### åªèƒ½è¿›è¡Œ k æ¬¡çš„è‚¡ç¥¨äº¤æ˜“

```java
public int maxProfit(int k, int[] prices) {
    int n = prices.length;
    if (k >= n / 2) {   // è¿™ç§æƒ…å†µä¸‹è¯¥é—®é¢˜é€€åŒ–ä¸ºæ™®é€šçš„è‚¡ç¥¨äº¤æ˜“é—®é¢˜
        int maxProfit = 0;
        for (int i = 1; i < n; i++) {
            if (prices[i] > prices[i - 1]) {
                maxProfit += prices[i] - prices[i - 1];
            }
        }
        return maxProfit;
    }
    int[][] maxProfit = new int[k + 1][n];
    for (int i = 1; i <= k; i++) {
        int localMax = maxProfit[i - 1][0] - prices[0];
        for (int j = 1; j < n; j++) {
            maxProfit[i][j] = Math.max(maxProfit[i][j - 1], prices[j] + localMax);
            localMax = Math.max(localMax, maxProfit[i - 1][j] - prices[j]);
        }
    }
    return maxProfit[k][n - 1];
}
```

### å­—ç¬¦ä¸²ç¼–è¾‘

#### åˆ é™¤ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å­—ç¬¦ä½¿å®ƒä»¬ç›¸ç­‰

```html
Input: "sea", "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
```

å¯ä»¥è½¬æ¢ä¸ºæ±‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—é—®é¢˜ã€‚

```java
public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }
    return m + n - 2 * dp[m][n];
}
```

#### ç¼–è¾‘è·ç¦»

```html
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

é¢˜ç›®æè¿°: ä¿®æ”¹ä¸€ä¸ªå­—ç¬¦ä¸²æˆä¸ºå¦ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½¿å¾—ä¿®æ”¹æ¬¡æ•°æœ€å°‘ã€‚ä¸€æ¬¡ä¿®æ”¹æ“ä½œåŒ…æ‹¬: æ’å…¥ä¸€ä¸ªå­—ç¬¦ã€åˆ é™¤ä¸€ä¸ªå­—ç¬¦ã€æ›¿æ¢ä¸€ä¸ªå­—ç¬¦ã€‚

```java
public int minDistance(String word1, String word2) {
    if (word1 == null || word2 == null) {
        return 0;
    }
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        dp[i][0] = i;
    }
    for (int i = 1; i <= n; i++) {
        dp[0][i] = i;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;
            }
        }
    }
    return dp[m][n];
}
```

#### å¤åˆ¶ç²˜è´´å­—ç¬¦

é¢˜ç›®æè¿°: æœ€å¼€å§‹åªæœ‰ä¸€ä¸ªå­—ç¬¦ Aï¼Œé—®éœ€è¦å¤šå°‘æ¬¡æ“ä½œèƒ½å¤Ÿå¾—åˆ° n ä¸ªå­—ç¬¦ Aï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥å¤åˆ¶å½“å‰æ‰€æœ‰çš„å­—ç¬¦ï¼Œæˆ–è€…ç²˜è´´ã€‚

```html
Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
```

```java
public int minSteps(int n) {
    if (n == 1) return 0;
    for (int i = 2; i <= Math.sqrt(n); i++) {
        if (n % i == 0) return i + minSteps(n / i);
    }
    return n;
}
```

```java
public int minSteps(int n) {
    int[] dp = new int[n + 1];
    int h = (int) Math.sqrt(n);
    for (int i = 2; i <= n; i++) {
        dp[i] = i;
        for (int j = 2; j <= h; j++) {
            if (i % j == 0) {
                dp[i] = dp[j] + dp[i / j];
                break;
            }
        }
    }
    return dp[n];
}
```



# ç®—æ³•æ€æƒ³ - è´ªå¿ƒç®—æ³•

æœ¬æ–‡ä¸»è¦ä»‹ç»ç®—æ³•ä¸­è´ªå¿ƒç®—æ³•çš„æ€æƒ³: ä¿è¯æ¯æ¬¡æ“ä½œéƒ½æ˜¯å±€éƒ¨æœ€ä¼˜çš„ï¼Œå¹¶ä¸”æœ€åå¾—åˆ°çš„ç»“æœæ˜¯å…¨å±€æœ€ä¼˜çš„ã€‚

## è´ªå¿ƒæ€æƒ³ç›¸å…³é¢˜ç›®

### åˆ†é…é¥¼å¹²

```html
Input: [1,2], [1,2,3]
Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
You have 3 cookies and their sizes are big enough to gratify all of the children,
You need to output 2.
```

é¢˜ç›®æè¿°: æ¯ä¸ªå­©å­éƒ½æœ‰ä¸€ä¸ªæ»¡è¶³åº¦ï¼Œæ¯ä¸ªé¥¼å¹²éƒ½æœ‰ä¸€ä¸ªå¤§å°ï¼Œåªæœ‰é¥¼å¹²çš„å¤§å°å¤§äºç­‰äºä¸€ä¸ªå­©å­çš„æ»¡è¶³åº¦ï¼Œè¯¥å­©å­æ‰ä¼šè·å¾—æ»¡è¶³ã€‚æ±‚è§£æœ€å¤šå¯ä»¥è·å¾—æ»¡è¶³çš„å­©å­æ•°é‡ã€‚



ç»™ä¸€ä¸ªå­©å­çš„é¥¼å¹²åº”å½“å°½é‡å°åˆèƒ½æ»¡è¶³è¯¥å­©å­ï¼Œè¿™æ ·å¤§é¥¼å¹²å°±èƒ½æ‹¿æ¥ç»™æ»¡è¶³åº¦æ¯”è¾ƒå¤§çš„å­©å­ã€‚å› ä¸ºæœ€å°çš„å­©å­æœ€å®¹æ˜“å¾—åˆ°æ»¡è¶³ï¼Œæ‰€ä»¥å…ˆæ»¡è¶³æœ€å°çš„å­©å­ã€‚



è¯æ˜: å‡è®¾åœ¨æŸæ¬¡é€‰æ‹©ä¸­ï¼Œè´ªå¿ƒç­–ç•¥é€‰æ‹©ç»™å½“å‰æ»¡è¶³åº¦æœ€å°çš„å­©å­åˆ†é…ç¬¬ m ä¸ªé¥¼å¹²ï¼Œç¬¬ m ä¸ªé¥¼å¹²ä¸ºå¯ä»¥æ»¡è¶³è¯¥å­©å­çš„æœ€å°é¥¼å¹²ã€‚å‡è®¾å­˜åœ¨ä¸€ç§æœ€ä¼˜ç­–ç•¥ï¼Œç»™è¯¥å­©å­åˆ†é…ç¬¬ n ä¸ªé¥¼å¹²ï¼Œå¹¶ä¸” m < nã€‚æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œç»è¿‡è¿™ä¸€è½®åˆ†é…ï¼Œè´ªå¿ƒç­–ç•¥åˆ†é…åå‰©ä¸‹çš„é¥¼å¹²ä¸€å®šæœ‰ä¸€ä¸ªæ¯”æœ€ä¼˜ç­–ç•¥æ¥å¾—å¤§ã€‚å› æ­¤åœ¨åç»­çš„åˆ†é…ä¸­ï¼Œè´ªå¿ƒç­–ç•¥ä¸€å®šèƒ½æ»¡è¶³æ›´å¤šçš„å­©å­ã€‚ä¹Ÿå°±æ˜¯è¯´ä¸å­˜åœ¨æ¯”è´ªå¿ƒç­–ç•¥æ›´ä¼˜çš„ç­–ç•¥ï¼Œå³è´ªå¿ƒç­–ç•¥å°±æ˜¯æœ€ä¼˜ç­–ç•¥ã€‚

```java
public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    int gi = 0, si = 0;
    while (gi < g.length && si < s.length) {
        if (g[gi] <= s[si]) {
            gi++;
        }
        si++;
    }
    return gi;
}
```

### ä¸é‡å çš„åŒºé—´ä¸ªæ•°

```html
Input: [ [1,2], [1,2], [1,2] ]

Output: 2

Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
```

```html
Input: [ [1,2], [2,3] ]

Output: 0

Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

é¢˜ç›®æè¿°: è®¡ç®—è®©ä¸€ç»„åŒºé—´ä¸é‡å æ‰€éœ€è¦ç§»é™¤çš„åŒºé—´ä¸ªæ•°ã€‚

è®¡ç®—æœ€å¤šèƒ½ç»„æˆçš„ä¸é‡å åŒºé—´ä¸ªæ•°ï¼Œç„¶åç”¨åŒºé—´æ€»ä¸ªæ•°å‡å»ä¸é‡å åŒºé—´çš„ä¸ªæ•°ã€‚

åœ¨æ¯æ¬¡é€‰æ‹©ä¸­ï¼ŒåŒºé—´çš„ç»“å°¾æœ€ä¸ºé‡è¦ï¼Œé€‰æ‹©çš„åŒºé—´ç»“å°¾è¶Šå°ï¼Œç•™ç»™åé¢çš„åŒºé—´çš„ç©ºé—´è¶Šå¤§ï¼Œé‚£ä¹ˆåé¢èƒ½å¤Ÿé€‰æ‹©çš„åŒºé—´ä¸ªæ•°ä¹Ÿå°±è¶Šå¤§ã€‚

æŒ‰åŒºé—´çš„ç»“å°¾è¿›è¡Œæ’åºï¼Œæ¯æ¬¡é€‰æ‹©ç»“å°¾æœ€å°ï¼Œå¹¶ä¸”å’Œå‰ä¸€ä¸ªåŒºé—´ä¸é‡å çš„åŒºé—´ã€‚

```java
public int eraseOverlapIntervals(Interval[] intervals) {
    if (intervals.length == 0) {
        return 0;
    }
    Arrays.sort(intervals, Comparator.comparingInt(o -> o.end));
    int cnt = 1;
    int end = intervals[0].end;
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i].start < end) {
            continue;
        }
        end = intervals[i].end;
        cnt++;
    }
    return intervals.length - cnt;
}
```

ä½¿ç”¨ lambda è¡¨ç¤ºå¼åˆ›å»º Comparator ä¼šå¯¼è‡´ç®—æ³•è¿è¡Œæ—¶é—´è¿‡é•¿ï¼Œå¦‚æœæ³¨é‡è¿è¡Œæ—¶é—´ï¼Œå¯ä»¥ä¿®æ”¹ä¸ºæ™®é€šåˆ›å»º Comparator è¯­å¥:

```java
Arrays.sort(intervals, new Comparator<Interval>() {
    @Override
    public int compare(Interval o1, Interval o2) {
        return o1.end - o2.end;
    }
});
```

### æŠ•é£é•–åˆºç ´æ°”çƒ

```html
Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2
```

é¢˜ç›®æè¿°: æ°”çƒåœ¨ä¸€ä¸ªæ°´å¹³æ•°è½´ä¸Šæ‘†æ”¾ï¼Œå¯ä»¥é‡å ï¼Œé£é•–å‚ç›´æŠ•å‘åæ ‡è½´ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ°”çƒéƒ½ä¼šåˆºç ´ã€‚æ±‚è§£æœ€å°çš„æŠ•é£é•–æ¬¡æ•°ä½¿æ‰€æœ‰æ°”çƒéƒ½è¢«åˆºç ´ã€‚

ä¹Ÿæ˜¯è®¡ç®—ä¸é‡å çš„åŒºé—´ä¸ªæ•°ï¼Œä¸è¿‡å’Œ Non-overlapping Intervals çš„åŒºåˆ«åœ¨äºï¼Œ[1, 2] å’Œ [2, 3] åœ¨æœ¬é¢˜ä¸­ç®—æ˜¯é‡å åŒºé—´ã€‚

```java
public int findMinArrowShots(int[][] points) {
    if (points.length == 0) {
        return 0;
    }
    Arrays.sort(points, Comparator.comparingInt(o -> o[1]));
    int cnt = 1, end = points[0][1];
    for (int i = 1; i < points.length; i++) {
        if (points[i][0] <= end) {
            continue;
        }
        cnt++;
        end = points[i][1];
    }
    return cnt;
}
```

### æ ¹æ®èº«é«˜å’Œåºå·é‡ç»„é˜Ÿåˆ—

```html
Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

é¢˜ç›®æè¿°: ä¸€ä¸ªå­¦ç”Ÿç”¨ä¸¤ä¸ªåˆ†é‡ (h, k) æè¿°ï¼Œh è¡¨ç¤ºèº«é«˜ï¼Œk è¡¨ç¤ºæ’åœ¨å‰é¢çš„æœ‰ k ä¸ªå­¦ç”Ÿçš„èº«é«˜æ¯”ä»–é«˜æˆ–è€…å’Œä»–ä¸€æ ·é«˜ã€‚

ä¸ºäº†åœ¨æ¯æ¬¡æ’å…¥æ“ä½œæ—¶ä¸å½±å“åç»­çš„æ“ä½œï¼Œèº«é«˜è¾ƒé«˜çš„å­¦ç”Ÿåº”è¯¥å…ˆåšæ’å…¥æ“ä½œï¼Œå¦åˆ™èº«é«˜è¾ƒå°çš„å­¦ç”ŸåŸå…ˆæ­£ç¡®æ’å…¥ç¬¬ k ä¸ªä½ç½®å¯èƒ½ä¼šå˜æˆç¬¬ k+1 ä¸ªä½ç½®ã€‚

èº«é«˜é™åºã€k å€¼å‡åºï¼Œç„¶åæŒ‰æ’å¥½åºçš„é¡ºåºæ’å…¥é˜Ÿåˆ—çš„ç¬¬ k ä¸ªä½ç½®ä¸­ã€‚

```java
public int[][] reconstructQueue(int[][] people) {
    if (people == null || people.length == 0 || people[0].length == 0) {
        return new int[0][0];
    }
    Arrays.sort(people, (a, b) -> (a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]));
    List<int[]> queue = new ArrayList<>();
    for (int[] p : people) {
        queue.add(p[1], p);
    }
    return queue.toArray(new int[queue.size()][]);
}
```



### åˆ†éš”å­—ç¬¦ä¸²ä½¿åŒç§å­—ç¬¦å‡ºç°åœ¨ä¸€èµ·

```html
Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
```

```java
public List<Integer> partitionLabels(String S) {
    int[] lastIndexsOfChar = new int[26];
    for (int i = 0; i < S.length(); i++) {
        lastIndexsOfChar[char2Index(S.charAt(i))] = i;
    }
    List<Integer> partitions = new ArrayList<>();
    int firstIndex = 0;
    while (firstIndex < S.length()) {
        int lastIndex = firstIndex;
        for (int i = firstIndex; i < S.length() && i <= lastIndex; i++) {
            int index = lastIndexsOfChar[char2Index(S.charAt(i))];
            if (index > lastIndex) {
                lastIndex = index;
            }
        }
        partitions.add(lastIndex - firstIndex + 1);
        firstIndex = lastIndex + 1;
    }
    return partitions;
}

private int char2Index(char c) {
    return c - 'a';
}
```

### ç§æ¤èŠ±æœµ

```html
Input: flowerbed = [1,0,0,0,1], n = 1
Output: True
```

é¢˜ç›®æè¿°: èŠ±æœµä¹‹é—´è‡³å°‘éœ€è¦ä¸€ä¸ªå•ä½çš„é—´éš”ï¼Œæ±‚è§£æ˜¯å¦èƒ½ç§ä¸‹ n æœµèŠ±ã€‚

```java
public boolean canPlaceFlowers(int[] flowerbed, int n) {
    int len = flowerbed.length;
    int cnt = 0;
    for (int i = 0; i < len && cnt < n; i++) {
        if (flowerbed[i] == 1) {
            continue;
        }
        int pre = i == 0 ? 0 : flowerbed[i - 1];
        int next = i == len - 1 ? 0 : flowerbed[i + 1];
        if (pre == 0 && next == 0) {
            cnt++;
            flowerbed[i] = 1;
        }
    }
    return cnt >= n;
}
```

### åˆ¤æ–­æ˜¯å¦ä¸ºå­åºåˆ—

```html
s = "abc", t = "ahbgdc"
Return true.
```

```java
public boolean isSubsequence(String s, String t) {
    int index = -1;
    for (char c : s.toCharArray()) {
        index = t.indexOf(c, index + 1);
        if (index == -1) {
            return false;
        }
    }
    return true;
}
```

### ä¿®æ”¹ä¸€ä¸ªæ•°æˆä¸ºéé€’å‡æ•°ç»„

```html
Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
```

é¢˜ç›®æè¿°: åˆ¤æ–­ä¸€ä¸ªæ•°ç»„èƒ½ä¸èƒ½åªä¿®æ”¹ä¸€ä¸ªæ•°å°±æˆä¸ºéé€’å‡æ•°ç»„ã€‚

åœ¨å‡ºç° nums[i] < nums[i - 1] æ—¶ï¼Œéœ€è¦è€ƒè™‘çš„æ˜¯åº”è¯¥ä¿®æ”¹æ•°ç»„çš„å“ªä¸ªæ•°ï¼Œä½¿å¾—æœ¬æ¬¡ä¿®æ”¹èƒ½ä½¿ i ä¹‹å‰çš„æ•°ç»„æˆä¸ºéé€’å‡æ•°ç»„ï¼Œå¹¶ä¸”  **ä¸å½±å“åç»­çš„æ“ä½œ** ã€‚ä¼˜å…ˆè€ƒè™‘ä»¤ nums[i - 1] = nums[i]ï¼Œå› ä¸ºå¦‚æœä¿®æ”¹ nums[i] = nums[i - 1] çš„è¯ï¼Œé‚£ä¹ˆ nums[i] è¿™ä¸ªæ•°ä¼šå˜å¤§ï¼Œå°±æœ‰å¯èƒ½æ¯” nums[i + 1] å¤§ï¼Œä»è€Œå½±å“äº†åç»­æ“ä½œã€‚è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒç‰¹åˆ«çš„æƒ…å†µå°±æ˜¯ nums[i] < nums[i - 2]ï¼Œåªä¿®æ”¹ nums[i - 1] = nums[i] ä¸èƒ½ä½¿æ•°ç»„æˆä¸ºéé€’å‡æ•°ç»„ï¼Œåªèƒ½ä¿®æ”¹ nums[i] = nums[i - 1]ã€‚

```java
public boolean checkPossibility(int[] nums) {
    int cnt = 0;
    for (int i = 1; i < nums.length && cnt < 2; i++) {
        if (nums[i] >= nums[i - 1]) {
            continue;
        }
        cnt++;
        if (i - 2 >= 0 && nums[i - 2] > nums[i]) {
            nums[i] = nums[i - 1];
        } else {
            nums[i - 1] = nums[i];
        }
    }
    return cnt <= 1;
}
```

### è‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š

é¢˜ç›®æè¿°: ä¸€æ¬¡è‚¡ç¥¨äº¤æ˜“åŒ…å«ä¹°å…¥å’Œå–å‡ºï¼Œå¤šä¸ªäº¤æ˜“ä¹‹é—´ä¸èƒ½äº¤å‰è¿›è¡Œã€‚

å¯¹äº [a, b, c, d]ï¼Œå¦‚æœæœ‰ a <= b <= c <= d ï¼Œé‚£ä¹ˆæœ€å¤§æ”¶ç›Šä¸º d - aã€‚è€Œ d - a = (d - c) + (c - b) + (b - a) ï¼Œå› æ­¤å½“è®¿é—®åˆ°ä¸€ä¸ª prices[i] ä¸” prices[i] - prices[i-1] > 0ï¼Œé‚£ä¹ˆå°±æŠŠ prices[i] - prices[i-1] æ·»åŠ åˆ°æ”¶ç›Šä¸­ï¼Œä»è€Œåœ¨å±€éƒ¨æœ€ä¼˜çš„æƒ…å†µä¸‹ä¹Ÿä¿è¯å…¨å±€æœ€ä¼˜ã€‚

```java
public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1]) {
            profit += (prices[i] - prices[i - 1]);
        }
    }
    return profit;
}
```



# ç®—æ³•æ€æƒ³ - äºŒåˆ†æ³•

æœ¬æ–‡ä¸»è¦ä»‹ç»ç®—æ³•æ€æƒ³ä¸­åˆ†æ²»ç®—æ³•é‡è¦çš„äºŒåˆ†æ³•ï¼Œæ¯”å¦‚äºŒåˆ†æŸ¥æ‰¾ï¼›äºŒåˆ†æŸ¥æ‰¾ä¹Ÿç§°æŠ˜åŠæŸ¥æ‰¾ï¼ˆBinary Searchï¼‰ï¼Œå®ƒæ˜¯ä¸€ç§æ•ˆç‡è¾ƒé«˜çš„æŸ¥æ‰¾æ–¹æ³•ã€‚ä½†æ˜¯ï¼ŒæŠ˜åŠæŸ¥æ‰¾è¦æ±‚çº¿æ€§è¡¨å¿…é¡»é‡‡ç”¨é¡ºåºå­˜å‚¨ç»“æ„ï¼Œè€Œä¸”è¡¨ä¸­å…ƒç´ æŒ‰å…³é”®å­—æœ‰åºæ’åˆ—ã€‚

## äºŒåˆ†æŸ¥æ‰¾

### æ­£å¸¸å®ç°

```java
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (nums[m] == key) {
            return m;
        } else if (nums[m] > key) {
            h = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```

### æ—¶é—´å¤æ‚åº¦

äºŒåˆ†æŸ¥æ‰¾ä¹Ÿç§°ä¸ºæŠ˜åŠæŸ¥æ‰¾ï¼Œæ¯æ¬¡éƒ½èƒ½å°†æŸ¥æ‰¾åŒºé—´å‡åŠï¼Œè¿™ç§æŠ˜åŠç‰¹æ€§çš„ç®—æ³•æ—¶é—´å¤æ‚åº¦éƒ½ä¸º O(logN)ã€‚

**m è®¡ç®—**

æœ‰ä¸¤ç§è®¡ç®—ä¸­å€¼ m çš„æ–¹å¼:

- m = (l + h) / 2
- m = l + (h - l) / 2

l + h å¯èƒ½å‡ºç°åŠ æ³•æº¢å‡ºï¼Œæœ€å¥½ä½¿ç”¨ç¬¬äºŒç§æ–¹å¼ã€‚

**è¿”å›å€¼**

å¾ªç¯é€€å‡ºæ—¶å¦‚æœä»ç„¶æ²¡æœ‰æŸ¥æ‰¾åˆ° keyï¼Œé‚£ä¹ˆè¡¨ç¤ºæŸ¥æ‰¾å¤±è´¥ã€‚å¯ä»¥æœ‰ä¸¤ç§è¿”å›å€¼:

- -1: ä»¥ä¸€ä¸ªé”™è¯¯ç è¡¨ç¤ºæ²¡æœ‰æŸ¥æ‰¾åˆ° key
- l: å°† key æ’å…¥åˆ° nums ä¸­çš„æ­£ç¡®ä½ç½®

### äºŒåˆ†æŸ¥æ‰¾å˜ç§

äºŒåˆ†æŸ¥æ‰¾å¯ä»¥æœ‰å¾ˆå¤šå˜ç§ï¼Œå˜ç§å®ç°è¦æ³¨æ„è¾¹ç•Œå€¼çš„åˆ¤æ–­ã€‚ä¾‹å¦‚åœ¨ä¸€ä¸ªæœ‰é‡å¤å…ƒç´ çš„æ•°ç»„ä¸­æŸ¥æ‰¾ key çš„æœ€å·¦ä½ç½®çš„å®ç°å¦‚ä¸‹:

```java
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= key) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```

è¯¥å®ç°å’Œæ­£å¸¸å®ç°æœ‰ä»¥ä¸‹ä¸åŒ:

- å¾ªç¯æ¡ä»¶ä¸º l < h
- h çš„èµ‹å€¼è¡¨è¾¾å¼ä¸º h = m
- æœ€åè¿”å› l è€Œä¸æ˜¯ -1

åœ¨ nums[m] >= key çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥æ¨å¯¼å‡ºæœ€å·¦ key ä½äº [l, m] åŒºé—´ä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªé—­åŒºé—´ã€‚h çš„èµ‹å€¼è¡¨è¾¾å¼ä¸º h = mï¼Œå› ä¸º m ä½ç½®ä¹Ÿå¯èƒ½æ˜¯è§£ã€‚

åœ¨ h çš„èµ‹å€¼è¡¨è¾¾å¼ä¸º h = mid çš„æƒ…å†µä¸‹ï¼Œå¦‚æœå¾ªç¯æ¡ä»¶ä¸º l <= hï¼Œé‚£ä¹ˆä¼šå‡ºç°å¾ªç¯æ— æ³•é€€å‡ºçš„æƒ…å†µï¼Œå› æ­¤å¾ªç¯æ¡ä»¶åªèƒ½æ˜¯ l < hã€‚ä»¥ä¸‹æ¼”ç¤ºäº†å¾ªç¯æ¡ä»¶ä¸º l <= h æ—¶å¾ªç¯æ— æ³•é€€å‡ºçš„æƒ…å†µ:

```sh
nums = {0, 1, 2}, key = 1
l   m   h
0   1   2  nums[m] >= key
0   0   1  nums[m] < key
1   1   1  nums[m] >= key
1   1   1  nums[m] >= key
...
```

å½“å¾ªç¯ä½“é€€å‡ºæ—¶ï¼Œä¸è¡¨ç¤ºæ²¡æœ‰æŸ¥æ‰¾åˆ° keyï¼Œå› æ­¤æœ€åè¿”å›çš„ç»“æœä¸åº”è¯¥ä¸º -1ã€‚ä¸ºäº†éªŒè¯æœ‰æ²¡æœ‰æŸ¥æ‰¾åˆ°ï¼Œéœ€è¦åœ¨è°ƒç”¨ç«¯åˆ¤æ–­ä¸€ä¸‹è¿”å›ä½ç½®ä¸Šçš„å€¼å’Œ key æ˜¯å¦ç›¸ç­‰ã€‚



#### æ±‚å¼€æ–¹

```html
Input: 4
Output: 2

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.
```

ä¸€ä¸ªæ•° x çš„å¼€æ–¹ sqrt ä¸€å®šåœ¨ 0 ~ x ä¹‹é—´ï¼Œå¹¶ä¸”æ»¡è¶³ sqrt == x / sqrtã€‚å¯ä»¥åˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾åœ¨ 0 ~ x ä¹‹é—´æŸ¥æ‰¾ sqrtã€‚

å¯¹äº x = 8ï¼Œå®ƒçš„å¼€æ–¹æ˜¯ 2.82842...ï¼Œæœ€ååº”è¯¥è¿”å› 2 è€Œä¸æ˜¯ 3ã€‚åœ¨å¾ªç¯æ¡ä»¶ä¸º l <= h å¹¶ä¸”å¾ªç¯é€€å‡ºæ—¶ï¼Œh æ€»æ˜¯æ¯” l å° 1ï¼Œä¹Ÿå°±æ˜¯è¯´ h = 2ï¼Œl = 3ï¼Œå› æ­¤æœ€åçš„è¿”å›å€¼åº”è¯¥ä¸º h è€Œä¸æ˜¯ lã€‚

```java
public int mySqrt(int x) {
    if (x <= 1) {
        return x;
    }
    int l = 1, h = x;
    while (l <= h) {
        int mid = l + (h - l) / 2;
        int sqrt = x / mid;
        if (sqrt == mid) {
            return mid;
        } else if (mid > sqrt) {
            h = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return h;
}
```

#### å¤§äºç»™å®šå…ƒç´ çš„æœ€å°å…ƒç´ 

```html
Input:
letters = ["c", "f", "j"]
target = "d"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "k"
Output: "c"
```

é¢˜ç›®æè¿°: ç»™å®šä¸€ä¸ªæœ‰åºçš„å­—ç¬¦æ•°ç»„ letters å’Œä¸€ä¸ªå­—ç¬¦ targetï¼Œè¦æ±‚æ‰¾å‡º letters ä¸­å¤§äº target çš„æœ€å°å­—ç¬¦ï¼Œå¦‚æœæ‰¾ä¸åˆ°å°±è¿”å›ç¬¬ 1 ä¸ªå­—ç¬¦ã€‚

```java
public char nextGreatestLetter(char[] letters, char target) {
    int n = letters.length;
    int l = 0, h = n - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (letters[m] <= target) {
            l = m + 1;
        } else {
            h = m - 1;
        }
    }
    return l < n ? letters[l] : letters[0];
}
```

#### æœ‰åºæ•°ç»„çš„ Single Element

```html
Input: [1,1,2,3,3,4,4,8,8]
Output: 2
```

é¢˜ç›®æè¿°: ä¸€ä¸ªæœ‰åºæ•°ç»„åªæœ‰ä¸€ä¸ªæ•°ä¸å‡ºç°ä¸¤æ¬¡ï¼Œæ‰¾å‡ºè¿™ä¸ªæ•°ã€‚è¦æ±‚ä»¥ O(logN) æ—¶é—´å¤æ‚åº¦è¿›è¡Œæ±‚è§£ã€‚

ä»¤ index ä¸º Single Element åœ¨æ•°ç»„ä¸­çš„ä½ç½®ã€‚å¦‚æœ m ä¸ºå¶æ•°ï¼Œå¹¶ä¸” m + 1 < indexï¼Œé‚£ä¹ˆ nums[m] == nums[m + 1]ï¼›m + 1 >= indexï¼Œé‚£ä¹ˆ nums[m] != nums[m + 1]ã€‚

ä»ä¸Šé¢çš„è§„å¾‹å¯ä»¥çŸ¥é“ï¼Œå¦‚æœ nums[m] == nums[m + 1]ï¼Œé‚£ä¹ˆ index æ‰€åœ¨çš„æ•°ç»„ä½ç½®ä¸º [m + 2, h]ï¼Œæ­¤æ—¶ä»¤ l = m + 2ï¼›å¦‚æœ nums[m] != nums[m + 1]ï¼Œé‚£ä¹ˆ index æ‰€åœ¨çš„æ•°ç»„ä½ç½®ä¸º [l, m]ï¼Œæ­¤æ—¶ä»¤ h = mã€‚

å› ä¸º h çš„èµ‹å€¼è¡¨è¾¾å¼ä¸º h = mï¼Œé‚£ä¹ˆå¾ªç¯æ¡ä»¶ä¹Ÿå°±åªèƒ½ä½¿ç”¨ l < h è¿™ç§å½¢å¼ã€‚

```java
public int singleNonDuplicate(int[] nums) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (m % 2 == 1) {
            m--;   
            // ä¿è¯ l/h/m éƒ½åœ¨å¶æ•°ä½ï¼Œä½¿å¾—æŸ¥æ‰¾åŒºé—´å¤§å°ä¸€ç›´éƒ½æ˜¯å¥‡æ•°
        }
        if (nums[m] == nums[m + 1]) {
            l = m + 2;
        } else {
            h = m;
        }
    }
    return nums[l];
}
```

#### ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬

é¢˜ç›®æè¿°: ç»™å®šä¸€ä¸ªå…ƒç´  n ä»£è¡¨æœ‰ [1, 2, ..., n] ç‰ˆæœ¬ï¼Œå¯ä»¥è°ƒç”¨ isBadVersion(int x) çŸ¥é“æŸä¸ªç‰ˆæœ¬æ˜¯å¦é”™è¯¯ï¼Œè¦æ±‚æ‰¾åˆ°ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬ã€‚

å¦‚æœç¬¬ m ä¸ªç‰ˆæœ¬å‡ºé”™ï¼Œåˆ™è¡¨ç¤ºç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬åœ¨ [l, m] ä¹‹é—´ï¼Œä»¤ h = mï¼›å¦åˆ™ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬åœ¨ [m + 1, h] ä¹‹é—´ï¼Œä»¤ l = m + 1ã€‚

å› ä¸º h çš„èµ‹å€¼è¡¨è¾¾å¼ä¸º h = mï¼Œå› æ­¤å¾ªç¯æ¡ä»¶ä¸º l < hã€‚

```java
public int firstBadVersion(int n) {
    int l = 1, h = n;
    while (l < h) {
        int mid = l + (h - l) / 2;
        if (isBadVersion(mid)) {
            h = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
}
```

#### æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—

```html
Input: [3,4,5,1,2],
Output: 1
```

```java
public int findMin(int[] nums) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] <= nums[h]) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return nums[l];
}
```

#### æŸ¥æ‰¾åŒºé—´

```html
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```

```java
public int[] searchRange(int[] nums, int target) {
    int first = binarySearch(nums, target);
    int last = binarySearch(nums, target + 1) - 1;
    if (first == nums.length || nums[first] != target) {
        return new int[]{-1, -1};
    } else {
        return new int[]{first, Math.max(first, last)};
    }
}

private int binarySearch(int[] nums, int target) {
    int l = 0, h = nums.length; // æ³¨æ„ h çš„åˆå§‹å€¼
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= target) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```



# ç®—æ³•æ€æƒ³ - æœç´¢ç®—æ³•

æœ¬æ–‡ä¸»è¦ä»‹ç»ç®—æ³•ä¸­æœç´¢ç®—æ³•çš„æ€æƒ³ï¼Œä¸»è¦åŒ…å«BFSï¼ŒDFSã€‚

## æœç´¢ç›¸å…³é¢˜ç›®

æ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢å¹¿æ³›è¿ç”¨äºæ ‘å’Œå›¾ä¸­ï¼Œä½†æ˜¯å®ƒä»¬çš„åº”ç”¨è¿œè¿œä¸æ­¢å¦‚æ­¤ã€‚

### BFS

![4ff355cf-9a7f-4468-af43-e5b02038facc](Images/4ff355cf-9a7f-4468-af43-e5b02038facc.jpg)





å¹¿åº¦ä¼˜å…ˆæœç´¢çš„æœç´¢è¿‡ç¨‹æœ‰ç‚¹åƒä¸€å±‚ä¸€å±‚åœ°è¿›è¡Œéå†ï¼Œæ¯å±‚éå†éƒ½ä»¥ä¸Šä¸€å±‚éå†çš„ç»“æœä½œä¸ºèµ·ç‚¹ï¼Œéå†ä¸€ä¸ªè·ç¦»èƒ½è®¿é—®åˆ°çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œéå†è¿‡çš„èŠ‚ç‚¹ä¸èƒ½å†æ¬¡è¢«éå†ã€‚

ç¬¬ä¸€å±‚:

- 0 -> {6,2,1,5};

ç¬¬äºŒå±‚:

- 6 -> {4}
- 2 -> {}
- 1 -> {}
- 5 -> {3}

ç¬¬ä¸‰å±‚:

- 4 -> {}
- 3 -> {}

å¯ä»¥çœ‹åˆ°ï¼Œæ¯ä¸€å±‚éå†çš„èŠ‚ç‚¹éƒ½ä¸æ ¹èŠ‚ç‚¹è·ç¦»ç›¸åŒã€‚è®¾ di è¡¨ç¤ºç¬¬ i ä¸ªèŠ‚ç‚¹ä¸æ ¹èŠ‚ç‚¹çš„è·ç¦»ï¼Œæ¨å¯¼å‡ºä¸€ä¸ªç»“è®º: å¯¹äºå…ˆéå†çš„èŠ‚ç‚¹ i ä¸åéå†çš„èŠ‚ç‚¹ jï¼Œæœ‰ di<=djã€‚åˆ©ç”¨è¿™ä¸ªç»“è®ºï¼Œå¯ä»¥æ±‚è§£æœ€çŸ­è·¯å¾„ç­‰  **æœ€ä¼˜è§£**  é—®é¢˜: ç¬¬ä¸€æ¬¡éå†åˆ°ç›®çš„èŠ‚ç‚¹ï¼Œå…¶æ‰€ç»è¿‡çš„è·¯å¾„ä¸ºæœ€çŸ­è·¯å¾„ã€‚åº”è¯¥æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨ BFS åªèƒ½æ±‚è§£æ— æƒå›¾çš„æœ€çŸ­è·¯å¾„ã€‚

åœ¨ç¨‹åºå®ç° BFS æ—¶éœ€è¦è€ƒè™‘ä»¥ä¸‹é—®é¢˜:

- é˜Ÿåˆ—: ç”¨æ¥å­˜å‚¨æ¯ä¸€è½®éå†å¾—åˆ°çš„èŠ‚ç‚¹ï¼›
- æ ‡è®°: å¯¹äºéå†è¿‡çš„èŠ‚ç‚¹ï¼Œåº”è¯¥å°†å®ƒæ ‡è®°ï¼Œé˜²æ­¢é‡å¤éå†ã€‚

#### è®¡ç®—åœ¨ç½‘æ ¼ä¸­ä»åŸç‚¹åˆ°ç‰¹å®šç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦

```html
[[1,1,0,1],
 [1,0,1,0],
 [1,1,1,1],
 [1,0,1,1]]
```

1 è¡¨ç¤ºå¯ä»¥ç»è¿‡æŸä¸ªä½ç½®ï¼Œæ±‚è§£ä» (0, 0) ä½ç½®åˆ° (tr, tc) ä½ç½®çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚

```java
public int minPathLength(int[][] grids, int tr, int tc) {
    final int[][] direction = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    final int m = grids.length, n = grids[0].length;
    Queue<Pair<Integer, Integer>> queue = new LinkedList<>();
    queue.add(new Pair<>(0, 0));
    int pathLength = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        pathLength++;
        while (size-- > 0) {
            Pair<Integer, Integer> cur = queue.poll();
            for (int[] d : direction) {
                int nr = cur.getKey() + d[0], nc = cur.getValue() + d[1];
                Pair<Integer, Integer> next = new Pair<>(nr, nc);
                if (next.getKey() < 0 || next.getValue() >= m
                        || next.getKey() < 0 || next.getValue() >= n) {

                    continue;
                }
                grids[next.getKey()][next.getValue()] = 0; // æ ‡è®°
                if (next.getKey() == tr && next.getValue() == tc) {
                    return pathLength;
                }
                queue.add(next);
            }
        }
    }
    return -1;
}
```

#### ç»„æˆæ•´æ•°çš„æœ€å°å¹³æ–¹æ•°æ•°é‡

```html
For example, given n = 12, return 3 because 12 = 4 + 4 + 4; 
given n = 13, return 2 because 13 = 4 + 9.
```

å¯ä»¥å°†æ¯ä¸ªæ•´æ•°çœ‹æˆå›¾ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœä¸¤ä¸ªæ•´æ•°ä¹‹å·®ä¸ºä¸€ä¸ªå¹³æ–¹æ•°ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæ•´æ•°æ‰€åœ¨çš„èŠ‚ç‚¹å°±æœ‰ä¸€æ¡è¾¹ã€‚

è¦æ±‚è§£æœ€å°çš„å¹³æ–¹æ•°æ•°é‡ï¼Œå°±æ˜¯æ±‚è§£ä»èŠ‚ç‚¹ n åˆ°èŠ‚ç‚¹ 0 çš„æœ€çŸ­è·¯å¾„ã€‚

æœ¬é¢˜ä¹Ÿå¯ä»¥ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ï¼Œåœ¨ä¹‹ååŠ¨æ€è§„åˆ’éƒ¨åˆ†ä¸­ä¼šå†æ¬¡å‡ºç°ã€‚

```java
public int numSquares(int n) {
    List<Integer> squares = generateSquares(n);
    Queue<Integer> queue = new LinkedList<>();
    boolean[] marked = new boolean[n + 1];
    queue.add(n);
    marked[n] = true;
    int level = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        level++;
        while (size-- > 0) {
            int cur = queue.poll();
            for (int s : squares) {
                int next = cur - s;
                if (next < 0) {
                    break;
                }
                if (next == 0) {
                    return level;
                }
                if (marked[next]) {
                    continue;
                }
                marked[next] = true;
                queue.add(cur - s);
            }
        }
    }
    return n;
}

/**
 * ç”Ÿæˆå°äº n çš„å¹³æ–¹æ•°åºåˆ—
 * @return 1,4,9,...
 */
private List<Integer> generateSquares(int n) {
    List<Integer> squares = new ArrayList<>();
    int square = 1;
    int diff = 3;
    while (square <= n) {
        squares.add(square);
        square += diff;
        diff += 2;
    }
    return squares;
}
```

#### æœ€çŸ­å•è¯è·¯å¾„

```html
Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is 
"hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
```

```html
Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
```

æ‰¾å‡ºä¸€æ¡ä» beginWord åˆ° endWord çš„æœ€çŸ­è·¯å¾„ï¼Œæ¯æ¬¡ç§»åŠ¨è§„å®šä¸ºæ”¹å˜ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”æ”¹å˜ä¹‹åçš„å­—ç¬¦ä¸²å¿…é¡»åœ¨ wordList ä¸­ã€‚

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    wordList.add(beginWord);
    int N = wordList.size();
    int start = N - 1;
    int end = 0;
    while (end < N && !wordList.get(end).equals(endWord)) {
        end++;
    }
    if (end == N) {
        return 0;
    }
    List<Integer>[] graphic = buildGraphic(wordList);
    return getShortestPath(graphic, start, end);
}

private List<Integer>[] buildGraphic(List<String> wordList) {
    int N = wordList.size();
    List<Integer>[] graphic = new List[N];
    for (int i = 0; i < N; i++) {
        graphic[i] = new ArrayList<>();
        for (int j = 0; j < N; j++) {
            if (isConnect(wordList.get(i), wordList.get(j))) {
                graphic[i].add(j);
            }
        }
    }
    return graphic;
}

private boolean isConnect(String s1, String s2) {
    int diffCnt = 0;
    for (int i = 0; i < s1.length() && diffCnt <= 1; i++) {
        if (s1.charAt(i) != s2.charAt(i)) {
            diffCnt++;
        }
    }
    return diffCnt == 1;
}

private int getShortestPath(List<Integer>[] graphic, int start, int end) {
    Queue<Integer> queue = new LinkedList<>();
    boolean[] marked = new boolean[graphic.length];
    queue.add(start);
    marked[start] = true;
    int path = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        path++;
        while (size-- > 0) {
            int cur = queue.poll();
            for (int next : graphic[cur]) {
                if (next == end) {
                    return path;
                }
                if (marked[next]) {
                    continue;
                }
                marked[next] = true;
                queue.add(next);
            }
        }
    }
    return 0;
}
```



### DFS

![f7f7e3e5-7dd4-4173-9999-576b9e2ac0a2](C:/Users/dsjprs/Desktop/PHO01/f7f7e3e5-7dd4-4173-9999-576b9e2ac0a2.png)

å¹¿åº¦ä¼˜å…ˆæœç´¢ä¸€å±‚ä¸€å±‚éå†ï¼Œæ¯ä¸€å±‚å¾—åˆ°çš„æ‰€æœ‰æ–°èŠ‚ç‚¹ï¼Œè¦ç”¨é˜Ÿåˆ—å­˜å‚¨èµ·æ¥ä»¥å¤‡ä¸‹ä¸€å±‚éå†çš„æ—¶å€™å†éå†ã€‚

è€Œæ·±åº¦ä¼˜å…ˆæœç´¢åœ¨å¾—åˆ°ä¸€ä¸ªæ–°èŠ‚ç‚¹æ—¶ç«‹é©¬å¯¹æ–°èŠ‚ç‚¹è¿›è¡Œéå†: ä»èŠ‚ç‚¹ 0 å‡ºå‘å¼€å§‹éå†ï¼Œå¾—åˆ°åˆ°æ–°èŠ‚ç‚¹ 6 æ—¶ï¼Œç«‹é©¬å¯¹æ–°èŠ‚ç‚¹ 6 è¿›è¡Œéå†ï¼Œå¾—åˆ°æ–°èŠ‚ç‚¹ 4ï¼›å¦‚æ­¤åå¤ä»¥è¿™ç§æ–¹å¼éå†æ–°èŠ‚ç‚¹ï¼Œç›´åˆ°æ²¡æœ‰æ–°èŠ‚ç‚¹äº†ï¼Œæ­¤æ—¶è¿”å›ã€‚è¿”å›åˆ°æ ¹èŠ‚ç‚¹ 0 çš„æƒ…å†µæ˜¯ï¼Œç»§ç»­å¯¹æ ¹èŠ‚ç‚¹ 0 è¿›è¡Œéå†ï¼Œå¾—åˆ°æ–°èŠ‚ç‚¹ 2ï¼Œç„¶åç»§ç»­ä»¥ä¸Šæ­¥éª¤ã€‚

ä»ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘ï¼Œä½¿ç”¨ DFS å¯¹ä¸€ä¸ªå›¾è¿›è¡Œéå†æ—¶ï¼Œèƒ½å¤Ÿéå†åˆ°çš„èŠ‚ç‚¹éƒ½æ˜¯ä»åˆå§‹èŠ‚ç‚¹å¯è¾¾çš„ï¼ŒDFS å¸¸ç”¨æ¥æ±‚è§£è¿™ç§  **å¯è¾¾æ€§**  é—®é¢˜ã€‚

åœ¨ç¨‹åºå®ç° DFS æ—¶éœ€è¦è€ƒè™‘ä»¥ä¸‹é—®é¢˜:

- æ ˆ: ç”¨æ ˆæ¥ä¿å­˜å½“å‰èŠ‚ç‚¹ä¿¡æ¯ï¼Œå½“éå†æ–°èŠ‚ç‚¹è¿”å›æ—¶èƒ½å¤Ÿç»§ç»­éå†å½“å‰èŠ‚ç‚¹ã€‚å¯ä»¥ä½¿ç”¨é€’å½’æ ˆã€‚
- æ ‡è®°: å’Œ BFS ä¸€æ ·åŒæ ·éœ€è¦å¯¹å·²ç»éå†è¿‡çš„èŠ‚ç‚¹è¿›è¡Œæ ‡è®°ã€‚

#### æŸ¥æ‰¾æœ€å¤§çš„è¿é€šé¢ç§¯

```html
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

```java
private int m, n;
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

public int maxAreaOfIsland(int[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    m = grid.length;
    n = grid[0].length;
    int maxArea = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            maxArea = Math.max(maxArea, dfs(grid, i, j));
        }
    }
    return maxArea;
}

private int dfs(int[][] grid, int r, int c) {
    if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] == 0) {
        return 0;
    }
    grid[r][c] = 0;
    int area = 1;
    for (int[] d : direction) {
        area += dfs(grid, r + d[0], c + d[1]);
    }
    return area;
}
```



#### çŸ©é˜µä¸­çš„è¿é€šåˆ†é‡æ•°ç›®

```html
Input:
11000
11000
00100
00011

Output: 3
```

å¯ä»¥å°†çŸ©é˜µè¡¨ç¤ºçœ‹æˆä¸€å¼ æœ‰å‘å›¾ã€‚

```java
private int m, n;
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    m = grid.length;
    n = grid[0].length;
    int islandsNum = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] != '0') {
                dfs(grid, i, j);
                islandsNum++;
            }
        }
    }
    return islandsNum;
}

private void dfs(char[][] grid, int i, int j) {
    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0') {
        return;
    }
    grid[i][j] = '0';
    for (int[] d : direction) {
        dfs(grid, i + d[0], j + d[1]);
    }
}
```

#### å¥½å‹å…³ç³»çš„è¿é€šåˆ†é‡æ•°ç›®

```html
Input:
[[1,1,0],
 [1,1,0],
 [0,0,1]]
Output: 2
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.
The 2nd student himself is in a friend circle. So return 2.
```

å¥½å‹å…³ç³»å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªæ— å‘å›¾ï¼Œä¾‹å¦‚ç¬¬ 0 ä¸ªäººä¸ç¬¬ 1 ä¸ªäººæ˜¯å¥½å‹ï¼Œé‚£ä¹ˆ M[0][1] å’Œ M[1][0] çš„å€¼éƒ½ä¸º 1ã€‚

```java
private int n;

public int findCircleNum(int[][] M) {
    n = M.length;
    int circleNum = 0;
    boolean[] hasVisited = new boolean[n];
    for (int i = 0; i < n; i++) {
        if (!hasVisited[i]) {
            dfs(M, i, hasVisited);
            circleNum++;
        }
    }
    return circleNum;
}

private void dfs(int[][] M, int i, boolean[] hasVisited) {
    hasVisited[i] = true;
    for (int k = 0; k < n; k++) {
        if (M[i][k] == 1 && !hasVisited[k]) {
            dfs(M, k, hasVisited);
        }
    }
}
```

#### å¡«å……å°é—­åŒºåŸŸ

```html
For example,
X X X X
X O O X
X X O X
X O X X

After running your function, the board should be:
X X X X
X X X X
X X X X
X O X X
```

ä½¿è¢« 'X' åŒ…å›´çš„ 'O' è½¬æ¢ä¸º 'X'ã€‚

å…ˆå¡«å……æœ€å¤–ä¾§ï¼Œå‰©ä¸‹çš„å°±æ˜¯é‡Œä¾§äº†ã€‚

```java
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
private int m, n;

public void solve(char[][] board) {
    if (board == null || board.length == 0) {
        return;
    }

    m = board.length;
    n = board[0].length;

    for (int i = 0; i < m; i++) {
        dfs(board, i, 0);
        dfs(board, i, n - 1);
    }
    for (int i = 0; i < n; i++) {
        dfs(board, 0, i);
        dfs(board, m - 1, i);
    }

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == 'T') {
                board[i][j] = 'O';
            } else if (board[i][j] == 'O') {
                board[i][j] = 'X';
            }
        }
    }
}

private void dfs(char[][] board, int r, int c) {
    if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] != 'O') {
        return;
    }
    board[r][c] = 'T';
    for (int[] d : direction) {
        dfs(board, r + d[0], c + d[1]);
    }
}
```

#### èƒ½åˆ°è¾¾çš„å¤ªå¹³æ´‹å’Œå¤§è¥¿æ´‹çš„åŒºåŸŸ

```html
Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:
[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
```

å·¦è¾¹å’Œä¸Šè¾¹æ˜¯å¤ªå¹³æ´‹ï¼Œå³è¾¹å’Œä¸‹è¾¹æ˜¯å¤§è¥¿æ´‹ï¼Œå†…éƒ¨çš„æ•°å­—ä»£è¡¨æµ·æ‹”ï¼Œæµ·æ‹”é«˜çš„åœ°æ–¹çš„æ°´èƒ½å¤Ÿæµåˆ°ä½çš„åœ°æ–¹ï¼Œæ±‚è§£æ°´èƒ½å¤Ÿæµåˆ°å¤ªå¹³æ´‹å’Œå¤§è¥¿æ´‹çš„æ‰€æœ‰ä½ç½®ã€‚

```java

private int m, n;
private int[][] matrix;
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

public List<int[]> pacificAtlantic(int[][] matrix) {
    List<int[]> ret = new ArrayList<>();
    if (matrix == null || matrix.length == 0) {
        return ret;
    }

    m = matrix.length;
    n = matrix[0].length;
    this.matrix = matrix;
    boolean[][] canReachP = new boolean[m][n];
    boolean[][] canReachA = new boolean[m][n];

    for (int i = 0; i < m; i++) {
        dfs(i, 0, canReachP);
        dfs(i, n - 1, canReachA);
    }
    for (int i = 0; i < n; i++) {
        dfs(0, i, canReachP);
        dfs(m - 1, i, canReachA);
    }

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (canReachP[i][j] && canReachA[i][j]) {
                ret.add(new int[]{i, j});
            }
        }
    }

    return ret;
}

private void dfs(int r, int c, boolean[][] canReach) {
    if (canReach[r][c]) {
        return;
    }
    canReach[r][c] = true;
    for (int[] d : direction) {
        int nextR = d[0] + r;
        int nextC = d[1] + c;
        if (nextR < 0 || nextR >= m || nextC < 0 || nextC >= n
                || matrix[r][c] > matrix[nextR][nextC]) {

            continue;
        }
        dfs(nextR, nextC, canReach);
    }
}
```



# ç®—æ³•æ€æƒ³ - å›æº¯ç®—æ³•

Backtracking(å›æº¯)å±äº DFS, æœ¬æ–‡ä¸»è¦ä»‹ç»ç®—æ³•ä¸­Backtrackingç®—æ³•çš„æ€æƒ³ã€‚å›æº¯ç®—æ³•å®é™…ä¸Šä¸€ä¸ªç±»ä¼¼æšä¸¾çš„æœç´¢å°è¯•è¿‡ç¨‹ï¼Œä¸»è¦æ˜¯åœ¨æœç´¢å°è¯•è¿‡ç¨‹ä¸­å¯»æ‰¾é—®é¢˜çš„è§£ï¼Œå½“å‘ç°å·²ä¸æ»¡è¶³æ±‚è§£æ¡ä»¶æ—¶ï¼Œå°±â€œå›æº¯â€è¿”å›ï¼Œå°è¯•åˆ«çš„è·¯å¾„ã€‚å›æº¯æ³•æ˜¯ä¸€ç§é€‰ä¼˜æœç´¢æ³•ï¼ŒæŒ‰é€‰ä¼˜æ¡ä»¶å‘å‰æœç´¢ï¼Œä»¥è¾¾åˆ°ç›®æ ‡ã€‚ä½†å½“æ¢ç´¢åˆ°æŸä¸€æ­¥æ—¶ï¼Œå‘ç°åŸå…ˆé€‰æ‹©å¹¶ä¸ä¼˜æˆ–è¾¾ä¸åˆ°ç›®æ ‡ï¼Œå°±é€€å›ä¸€æ­¥é‡æ–°é€‰æ‹©ï¼Œè¿™ç§èµ°ä¸é€šå°±é€€å›å†èµ°çš„æŠ€æœ¯ä¸ºå›æº¯æ³•

## Backtracking

- æ™®é€š DFS ä¸»è¦ç”¨åœ¨  **å¯è¾¾æ€§é—®é¢˜** ï¼Œè¿™ç§é—®é¢˜åªéœ€è¦æ‰§è¡Œåˆ°ç‰¹ç‚¹çš„ä½ç½®ç„¶åè¿”å›å³å¯ã€‚
- è€Œ Backtracking ä¸»è¦ç”¨äºæ±‚è§£  **æ’åˆ—ç»„åˆ**  é—®é¢˜ï¼Œä¾‹å¦‚æœ‰ { 'a','b','c' } ä¸‰ä¸ªå­—ç¬¦ï¼Œæ±‚è§£æ‰€æœ‰ç”±è¿™ä¸‰ä¸ªå­—ç¬¦æ’åˆ—å¾—åˆ°çš„å­—ç¬¦ä¸²ï¼Œè¿™ç§é—®é¢˜åœ¨æ‰§è¡Œåˆ°ç‰¹å®šçš„ä½ç½®è¿”å›ä¹‹åè¿˜ä¼šç»§ç»­æ‰§è¡Œæ±‚è§£è¿‡ç¨‹ã€‚

å› ä¸º Backtracking ä¸æ˜¯ç«‹å³å°±è¿”å›ï¼Œè€Œè¦ç»§ç»­æ±‚è§£ï¼Œå› æ­¤åœ¨ç¨‹åºå®ç°æ—¶ï¼Œéœ€è¦æ³¨æ„å¯¹å…ƒç´ çš„æ ‡è®°é—®é¢˜:

- åœ¨è®¿é—®ä¸€ä¸ªæ–°å…ƒç´ è¿›å…¥æ–°çš„é€’å½’è°ƒç”¨æ—¶ï¼Œéœ€è¦å°†æ–°å…ƒç´ æ ‡è®°ä¸ºå·²ç»è®¿é—®ï¼Œè¿™æ ·æ‰èƒ½åœ¨ç»§ç»­é€’å½’è°ƒç”¨æ—¶ä¸ç”¨é‡å¤è®¿é—®è¯¥å…ƒç´ ï¼›
- ä½†æ˜¯åœ¨é€’å½’è¿”å›æ—¶ï¼Œéœ€è¦å°†å…ƒç´ æ ‡è®°ä¸ºæœªè®¿é—®ï¼Œå› ä¸ºåªéœ€è¦ä¿è¯åœ¨ä¸€ä¸ªé€’å½’é“¾ä¸­ä¸åŒæ—¶è®¿é—®ä¸€ä¸ªå…ƒç´ ï¼Œå¯ä»¥è®¿é—®å·²ç»è®¿é—®è¿‡ä½†æ˜¯ä¸åœ¨å½“å‰é€’å½’é“¾ä¸­çš„å…ƒç´ ã€‚

### æ•°å­—é”®ç›˜ç»„åˆ

![a3f34241-bb80-4879-8ec9-dff2d81b514e](Images/a3f34241-bb80-4879-8ec9-dff2d81b514e.jpg)



```html
Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

```java

private static final String[] KEYS = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

public List<String> letterCombinations(String digits) {
    List<String> combinations = new ArrayList<>();
    if (digits == null || digits.length() == 0) {
        return combinations;
    }
    doCombination(new StringBuilder(), combinations, digits);
    return combinations;
}

private void doCombination(StringBuilder prefix, List<String> combinations, final String digits) {
    if (prefix.length() == digits.length()) {
        combinations.add(prefix.toString());
        return;
    }
    int curDigits = digits.charAt(prefix.length()) - '0';
    String letters = KEYS[curDigits];
    for (char c : letters.toCharArray()) {
        prefix.append(c);                         // æ·»åŠ 
        doCombination(prefix, combinations, digits);
        prefix.deleteCharAt(prefix.length() - 1); // åˆ é™¤
    }
}
```

### IP åœ°å€åˆ’åˆ†

```html
Given "25525511135",
return ["255.255.11.135", "255.255.111.35"].
```

```java
public List<String> restoreIpAddresses(String s) {
    List<String> addresses = new ArrayList<>();
    StringBuilder tempAddress = new StringBuilder();
    doRestore(0, tempAddress, addresses, s);
    return addresses;
}

private void doRestore(int k, StringBuilder tempAddress, List<String> addresses, String s) {
    if (k == 4 || s.length() == 0) {
        if (k == 4 && s.length() == 0) {
            addresses.add(tempAddress.toString());
        }
        return;
    }
    for (int i = 0; i < s.length() && i <= 2; i++) {
        if (i != 0 && s.charAt(0) == '0') {
            break;
        }
        String part = s.substring(0, i + 1);
        if (Integer.valueOf(part) <= 255) {
            if (tempAddress.length() != 0) {
                part = "." + part;
            }
            tempAddress.append(part);
            doRestore(k + 1, tempAddress, addresses, s.substring(i + 1));
            tempAddress.delete(tempAddress.length() - part.length(), tempAddress.length());
        }
    }
}
```

### åœ¨çŸ©é˜µä¸­å¯»æ‰¾å­—ç¬¦ä¸²

```html
For example,
Given board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.
```

```java
private final static int[][] direction = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
private int m;
private int n;

public boolean exist(char[][] board, String word) {
    if (word == null || word.length() == 0) {
        return true;
    }
    if (board == null || board.length == 0 || board[0].length == 0) {
        return false;
    }

    m = board.length;
    n = board[0].length;
    boolean[][] hasVisited = new boolean[m][n];

    for (int r = 0; r < m; r++) {
        for (int c = 0; c < n; c++) {
            if (backtracking(0, r, c, hasVisited, board, word)) {
                return true;
            }
        }
    }

    return false;
}

private boolean backtracking(int curLen, int r, int c, boolean[][] visited, final char[][] board, final String word) {
    if (curLen == word.length()) {
        return true;
    }
    if (r < 0 || r >= m || c < 0 || c >= n
            || board[r][c] != word.charAt(curLen) || visited[r][c]) {

        return false;
    }

    visited[r][c] = true;

    for (int[] d : direction) {
        if (backtracking(curLen + 1, r + d[0], c + d[1], visited, board, word)) {
            return true;
        }
    }

    visited[r][c] = false;

    return false;
}
```

### è¾“å‡ºäºŒå‰æ ‘ä¸­æ‰€æœ‰ä»æ ¹åˆ°å¶å­çš„è·¯å¾„

```html
  1
 /  \
2    3
 \
  5
```

```html
["1->2->5", "1->3"]
```

```java

public List<String> binaryTreePaths(TreeNode root) {
    List<String> paths = new ArrayList<>();
    if (root == null) {
        return paths;
    }
    List<Integer> values = new ArrayList<>();
    backtracking(root, values, paths);
    return paths;
}

private void backtracking(TreeNode node, List<Integer> values, List<String> paths) {
    if (node == null) {
        return;
    }
    values.add(node.val);
    if (isLeaf(node)) {
        paths.add(buildPath(values));
    } else {
        backtracking(node.left, values, paths);
        backtracking(node.right, values, paths);
    }
    values.remove(values.size() - 1);
}

private boolean isLeaf(TreeNode node) {
    return node.left == null && node.right == null;
}

private String buildPath(List<Integer> values) {
    StringBuilder str = new StringBuilder();
    for (int i = 0; i < values.size(); i++) {
        str.append(values.get(i));
        if (i != values.size() - 1) {
            str.append("->");
        }
    }
    return str.toString();
}
```

### æ’åˆ—

```html
[1,2,3] have the following permutations:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> permutes = new ArrayList<>();
    List<Integer> permuteList = new ArrayList<>();
    boolean[] hasVisited = new boolean[nums.length];
    backtracking(permuteList, permutes, hasVisited, nums);
    return permutes;
}

private void backtracking(List<Integer> permuteList, List<List<Integer>> permutes, boolean[] visited, final int[] nums) {
    if (permuteList.size() == nums.length) {
        permutes.add(new ArrayList<>(permuteList)); // é‡æ–°æ„é€ ä¸€ä¸ª List
        return;
    }
    for (int i = 0; i < visited.length; i++) {
        if (visited[i]) {
            continue;
        }
        visited[i] = true;
        permuteList.add(nums[i]);
        backtracking(permuteList, permutes, visited, nums);
        permuteList.remove(permuteList.size() - 1);
        visited[i] = false;
    }
}
```

### å«æœ‰ç›¸åŒå…ƒç´ æ±‚æ’åˆ—

```html
[1,1,2] have the following unique permutations:
[[1,1,2], [1,2,1], [2,1,1]]
```

æ•°ç»„å…ƒç´ å¯èƒ½å«æœ‰ç›¸åŒçš„å…ƒç´ ï¼Œè¿›è¡Œæ’åˆ—æ—¶å°±æœ‰å¯èƒ½å‡ºç°é‡å¤çš„æ’åˆ—ï¼Œè¦æ±‚é‡å¤çš„æ’åˆ—åªè¿”å›ä¸€ä¸ªã€‚

åœ¨å®ç°ä¸Šï¼Œå’Œ Permutations ä¸åŒçš„æ˜¯è¦å…ˆæ’åºï¼Œç„¶ååœ¨æ·»åŠ ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œåˆ¤æ–­è¿™ä¸ªå…ƒç´ æ˜¯å¦ç­‰äºå‰ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœç­‰äºï¼Œå¹¶ä¸”å‰ä¸€ä¸ªå…ƒç´ è¿˜æœªè®¿é—®ï¼Œé‚£ä¹ˆå°±è·³è¿‡è¿™ä¸ªå…ƒç´ ã€‚

```java
public List<List<Integer>> permuteUnique(int[] nums) {
    List<List<Integer>> permutes = new ArrayList<>();
    List<Integer> permuteList = new ArrayList<>();
    Arrays.sort(nums);  // æ’åº
    boolean[] hasVisited = new boolean[nums.length];
    backtracking(permuteList, permutes, hasVisited, nums);
    return permutes;
}

private void backtracking(List<Integer> permuteList, List<List<Integer>> permutes, boolean[] visited, final int[] nums) {
    if (permuteList.size() == nums.length) {
        permutes.add(new ArrayList<>(permuteList));
        return;
    }

    for (int i = 0; i < visited.length; i++) {
        if (i != 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {
            continue;  // é˜²æ­¢é‡å¤
        }
        if (visited[i]){
            continue;
        }
        visited[i] = true;
        permuteList.add(nums[i]);
        backtracking(permuteList, permutes, visited, nums);
        permuteList.remove(permuteList.size() - 1);
        visited[i] = false;
    }
}
```

### ç»„åˆ

```html
If n = 4 and k = 2, a solution is:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
public List<List<Integer>> combine(int n, int k) {
    List<List<Integer>> combinations = new ArrayList<>();
    List<Integer> combineList = new ArrayList<>();
    backtracking(combineList, combinations, 1, k, n);
    return combinations;
}

private void backtracking(List<Integer> combineList, List<List<Integer>> combinations, int start, int k, final int n) {
    if (k == 0) {
        combinations.add(new ArrayList<>(combineList));
        return;
    }
    for (int i = start; i <= n - k + 1; i++) {  // å‰ªæ
        combineList.add(i);
        backtracking(combineList, combinations, i + 1, k - 1, n);
        combineList.remove(combineList.size() - 1);
    }
}
```

### ç»„åˆæ±‚å’Œ

```html
given candidate set [2, 3, 6, 7] and target 7,
A solution set is:
[[7],[2, 2, 3]]
```

```java
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> combinations = new ArrayList<>();
    backtracking(new ArrayList<>(), combinations, 0, target, candidates);
    return combinations;
}

private void backtracking(List<Integer> tempCombination, List<List<Integer>> combinations,
                          int start, int target, final int[] candidates) {

    if (target == 0) {
        combinations.add(new ArrayList<>(tempCombination));
        return;
    }
    for (int i = start; i < candidates.length; i++) {
        if (candidates[i] <= target) {
            tempCombination.add(candidates[i]);
            backtracking(tempCombination, combinations, i, target - candidates[i], candidates);
            tempCombination.remove(tempCombination.size() - 1);
        }
    }
}
```

### å«æœ‰ç›¸åŒå…ƒç´ çš„æ±‚ç»„åˆæ±‚å’Œ

```html
For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

```java
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    List<List<Integer>> combinations = new ArrayList<>();
    Arrays.sort(candidates);
    backtracking(new ArrayList<>(), combinations, new boolean[candidates.length], 0, target, candidates);
    return combinations;
}

private void backtracking(List<Integer> tempCombination, List<List<Integer>> combinations,
                          boolean[] hasVisited, int start, int target, final int[] candidates) {

    if (target == 0) {
        combinations.add(new ArrayList<>(tempCombination));
        return;
    }
    for (int i = start; i < candidates.length; i++) {
        if (i != 0 && candidates[i] == candidates[i - 1] && !hasVisited[i - 1]) {
            continue;
        }
        if (candidates[i] <= target) {
            tempCombination.add(candidates[i]);
            hasVisited[i] = true;
            backtracking(tempCombination, combinations, hasVisited, i + 1, target - candidates[i], candidates);
            hasVisited[i] = false;
            tempCombination.remove(tempCombination.size() - 1);
        }
    }
}
```

### 1-9 æ•°å­—çš„ç»„åˆæ±‚å’Œ

```html
Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]
```

ä» 1-9 æ•°å­—ä¸­é€‰å‡º k ä¸ªæ•°ä¸é‡å¤çš„æ•°ï¼Œä½¿å¾—å®ƒä»¬çš„å’Œä¸º nã€‚

```java
public List<List<Integer>> combinationSum3(int k, int n) {
    List<List<Integer>> combinations = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    backtracking(k, n, 1, path, combinations);
    return combinations;
}

private void backtracking(int k, int n, int start,
                          List<Integer> tempCombination, List<List<Integer>> combinations) {

    if (k == 0 && n == 0) {
        combinations.add(new ArrayList<>(tempCombination));
        return;
    }
    if (k == 0 || n == 0) {
        return;
    }
    for (int i = start; i <= 9; i++) {
        tempCombination.add(i);
        backtracking(k - 1, n - i, i + 1, tempCombination, combinations);
        tempCombination.remove(tempCombination.size() - 1);
    }
}
```



### å­é›†

æ‰¾å‡ºé›†åˆçš„æ‰€æœ‰å­é›†ï¼Œå­é›†ä¸èƒ½é‡å¤ï¼Œ[1, 2] å’Œ [2, 1] è¿™ç§å­é›†ç®—é‡å¤

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> subsets = new ArrayList<>();
    List<Integer> tempSubset = new ArrayList<>();
    for (int size = 0; size <= nums.length; size++) {
        backtracking(0, tempSubset, subsets, size, nums); // ä¸åŒçš„å­é›†å¤§å°
    }
    return subsets;
}

private void backtracking(int start, List<Integer> tempSubset, List<List<Integer>> subsets,
                          final int size, final int[] nums) {

    if (tempSubset.size() == size) {
        subsets.add(new ArrayList<>(tempSubset));
        return;
    }
    for (int i = start; i < nums.length; i++) {
        tempSubset.add(nums[i]);
        backtracking(i + 1, tempSubset, subsets, size, nums);
        tempSubset.remove(tempSubset.size() - 1);
    }
}
```

### å«æœ‰ç›¸åŒå…ƒç´ æ±‚å­é›†

```html
For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

```java
public List<List<Integer>> subsetsWithDup(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> subsets = new ArrayList<>();
    List<Integer> tempSubset = new ArrayList<>();
    boolean[] hasVisited = new boolean[nums.length];
    for (int size = 0; size <= nums.length; size++) {
        backtracking(0, tempSubset, subsets, hasVisited, size, nums); // ä¸åŒçš„å­é›†å¤§å°
    }
    return subsets;
}

private void backtracking(int start, List<Integer> tempSubset, List<List<Integer>> subsets, boolean[] hasVisited,
                          final int size, final int[] nums) {

    if (tempSubset.size() == size) {
        subsets.add(new ArrayList<>(tempSubset));
        return;
    }
    for (int i = start; i < nums.length; i++) {
        if (i != 0 && nums[i] == nums[i - 1] && !hasVisited[i - 1]) {
            continue;
        }
        tempSubset.add(nums[i]);
        hasVisited[i] = true;
        backtracking(i + 1, tempSubset, subsets, hasVisited, size, nums);
        hasVisited[i] = false;
        tempSubset.remove(tempSubset.size() - 1);
    }
}
```

### åˆ†å‰²å­—ç¬¦ä¸²ä½¿å¾—æ¯ä¸ªéƒ¨åˆ†éƒ½æ˜¯å›æ–‡æ•°

```html
For example, given s = "aab",
Return

[
  ["aa","b"],
  ["a","a","b"]
]
```

```java
public List<List<String>> partition(String s) {
    List<List<String>> partitions = new ArrayList<>();
    List<String> tempPartition = new ArrayList<>();
    doPartition(s, partitions, tempPartition);
    return partitions;
}

private void doPartition(String s, List<List<String>> partitions, List<String> tempPartition) {
    if (s.length() == 0) {
        partitions.add(new ArrayList<>(tempPartition));
        return;
    }
    for (int i = 0; i < s.length(); i++) {
        if (isPalindrome(s, 0, i)) {
            tempPartition.add(s.substring(0, i + 1));
            doPartition(s.substring(i + 1), partitions, tempPartition);
            tempPartition.remove(tempPartition.size() - 1);
        }
    }
}

private boolean isPalindrome(String s, int begin, int end) {
    while (begin < end) {
        if (s.charAt(begin++) != s.charAt(end--)) {
            return false;
        }
    }
    return true;
}
```

### æ•°ç‹¬

![1ca52246-c443-48ae-b1f8-1cafc09ec75c](Images/1ca52246-c443-48ae-b1f8-1cafc09ec75c.png)



```java
private boolean[][] rowsUsed = new boolean[9][10];
private boolean[][] colsUsed = new boolean[9][10];
private boolean[][] cubesUsed = new boolean[9][10];
private char[][] board;

public void solveSudoku(char[][] board) {
    this.board = board;
    for (int i = 0; i < 9; i++)
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') {
                continue;
            }
            int num = board[i][j] - '0';
            rowsUsed[i][num] = true;
            colsUsed[j][num] = true;
            cubesUsed[cubeNum(i, j)][num] = true;
        }

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            backtracking(i, j);
        }
    }
}

private boolean backtracking(int row, int col) {
    while (row < 9 && board[row][col] != '.') {
        row = col == 8 ? row + 1 : row;
        col = col == 8 ? 0 : col + 1;
    }
    if (row == 9) {
        return true;
    }
    for (int num = 1; num <= 9; num++) {
        if (rowsUsed[row][num] || colsUsed[col][num] || cubesUsed[cubeNum(row, col)][num]) {
            continue;
        }
        rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = true;
        board[row][col] = (char) (num + '0');
        if (backtracking(row, col)) {
            return true;
        }
        board[row][col] = '.';
        rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = false;
    }
    return false;
}

private int cubeNum(int i, int j) {
    int r = i / 3;
    int c = j / 3;
    return r * 3 + c;
}
```

### N çš‡å

![1f080e53-4758-406c-bb5f-dbedf89b63ce](Images/1f080e53-4758-406c-bb5f-dbedf89b63ce.jpg)



åœ¨ n*n çš„çŸ©é˜µä¸­æ‘†æ”¾ n ä¸ªçš‡åï¼Œå¹¶ä¸”æ¯ä¸ªçš‡åä¸èƒ½åœ¨åŒä¸€è¡Œï¼ŒåŒä¸€åˆ—ï¼ŒåŒä¸€å¯¹è§’çº¿ä¸Šï¼Œæ±‚æ‰€æœ‰çš„ n çš‡åçš„è§£ã€‚

ä¸€è¡Œä¸€è¡Œåœ°æ‘†æ”¾ï¼Œåœ¨ç¡®å®šä¸€è¡Œä¸­çš„é‚£ä¸ªçš‡ååº”è¯¥æ‘†åœ¨å“ªä¸€åˆ—æ—¶ï¼Œéœ€è¦ç”¨ä¸‰ä¸ªæ ‡è®°æ•°ç»„æ¥ç¡®å®šæŸä¸€åˆ—æ˜¯å¦åˆæ³•ï¼Œè¿™ä¸‰ä¸ªæ ‡è®°æ•°ç»„åˆ†åˆ«ä¸º: åˆ—æ ‡è®°æ•°ç»„ã€45 åº¦å¯¹è§’çº¿æ ‡è®°æ•°ç»„å’Œ 135 åº¦å¯¹è§’çº¿æ ‡è®°æ•°ç»„ã€‚

45 åº¦å¯¹è§’çº¿æ ‡è®°æ•°ç»„çš„ç»´åº¦ä¸º 2 * n - 1ï¼Œé€šè¿‡ä¸‹å›¾å¯ä»¥æ˜ç¡® (r, c) çš„ä½ç½®æ‰€åœ¨çš„æ•°ç»„ä¸‹æ ‡ä¸º r + cã€‚

![85583359-1b45-45f2-9811-4f7bb9a64db7](Images/85583359-1b45-45f2-9811-4f7bb9a64db7.jpg)



135 åº¦å¯¹è§’çº¿æ ‡è®°æ•°ç»„çš„ç»´åº¦ä¹Ÿæ˜¯ 2 * n - 1ï¼Œ(r, c) çš„ä½ç½®æ‰€åœ¨çš„æ•°ç»„ä¸‹æ ‡ä¸º n - 1 - (r - c)ã€‚

![9e80f75a-b12b-4344-80c8-1f9ccc2d5246](Images/9e80f75a-b12b-4344-80c8-1f9ccc2d5246.jpg)

```java
private List<List<String>> solutions;
private char[][] nQueens;
private boolean[] colUsed;
private boolean[] diagonals45Used;
private boolean[] diagonals135Used;
private int n;

public List<List<String>> solveNQueens(int n) {
    solutions = new ArrayList<>();
    nQueens = new char[n][n];
    for (int i = 0; i < n; i++) {
        Arrays.fill(nQueens[i], '.');
    }
    colUsed = new boolean[n];
    diagonals45Used = new boolean[2 * n - 1];
    diagonals135Used = new boolean[2 * n - 1];
    this.n = n;
    backtracking(0);
    return solutions;
}

private void backtracking(int row) {
    if (row == n) {
        List<String> list = new ArrayList<>();
        for (char[] chars : nQueens) {
            list.add(new String(chars));
        }
        solutions.add(list);
        return;
    }

    for (int col = 0; col < n; col++) {
        int diagonals45Idx = row + col;
        int diagonals135Idx = n - 1 - (row - col);
        if (colUsed[col] || diagonals45Used[diagonals45Idx] || diagonals135Used[diagonals135Idx]) {
            continue;
        }
        nQueens[row][col] = 'Q';
        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = true;
        backtracking(row + 1);
        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = false;
        nQueens[row][col] = '.';
    }
}
```
